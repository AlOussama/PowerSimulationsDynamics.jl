var documenterSearchIndex = {"docs":
[{"location":"component_models/inner_control/#Inner-Loop-Controls","page":"Inner Control","title":"Inner Loop Controls","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"This component defines voltage and current controllers to generate the reference signal for the converter. Although in many controls the current and voltage control are separate blocks we propose a more general control approach that considers them as a joint control logic.","category":"page"},{"location":"component_models/inner_control/#Integrated-Virtual-Impedance,-Voltage-and-Current-Controller-[CurrentControl]","page":"Inner Control","title":"Integrated Virtual Impedance, Voltage and Current Controller [CurrentControl]","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"The following model receives both the outer loop control frequency and reference voltage signal to generate the reference signal for the converters. The virtual impedance plays a similar role of the impedance of a synchronous generator. A PI voltage controller is used to generate the current signal that is used in the PI current controller to finally generate the voltage reference signal for the converters.","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\n    dotxi_d = v_dtextvi^textref - v_d tag3a \n    dotxi_q = v_qtextvi^textref - v_q tag3b \n    dotgamma_d = i_dtextcv^textref - i_dtextcv tag3c \n    dotgamma_q = i_qtextcv^textref - i_qtextcv tag3d \n    dotphi_d = omega_textad(v_d - phi_d) tag3e \n    dotphi_q = omega_textad(v_q - phi_q) tag3f\nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"with","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    v_dtextvi^textref = v_textolc^textref - r_v i_d + omega_textolc l_v i_q tag3g \n    v_qtextvi^textref = - r_v i_q - omega_textolc l_v i_d tag3h \n    i_dtextcv^textref = k_pvleft(v_dtextvi^textref - v_qright) + k_iv xi_d - c_f omega_textolc v_q + k_textffii_d tag3i \n    i_qtextcv^textref = k_pvleft(v_qtextvi^textref - v_qright) + k_iv xi_q + c_f omega_textolc v_d + k_textffii_q tag3j \n    v_d^textref-signal = k_pc left(i_dtextcv^textref - i_dtextcvright) + k_ic gamma_d - omega_textolc l_f i_qtextcv + k_textffvv_d - k_textad(v_d - phi_d) tag3k \n    v_q^textref-signal = k_pc left(i_qtextcv^textref - i_qtextcvright) + k_ic gamma_q + omega_textolc l_f i_dtextcv + k_textffvv_q - k_textad(v_q - phi_q) tag3l\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"In here the transformation to the dq reference frame is using the outer-loop reference angle as:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\nv_d + jv_q = (v_r + jv_i)e^-jdeltatheta_olc \ni_d + ji_q = (i_r + ji_i)e^-jdeltatheta_olc\nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"that again v_r + jv_i could be in the capacitor or the last branch of the filter (i.e. the point of common coupling). For LCL filters it is considered in the capacitor. In the case of the converter, the transformation is directly","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\ni_dtextcv + ji_qtextcv = (i_rtextcv + ji_itextcv)e^-jdeltatheta_olc\nendalign*","category":"page"},{"location":"quick_start_guide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"You can access example data in the Power Systems Test Data Repository, the data can be downloaded with the PowerSystems.jl submodule UtilsData.","category":"page"},{"location":"quick_start_guide/#Loading-data","page":"Quick Start Guide","title":"Loading data","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Data can be loaded from a pss/e raw file and a pss/e dyr file.","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"using PowerSystems, PowerSimulationsDynamics, Sundials, Plots\nDATA_DIR = download(PowerSystems.UtilsData.TestData, folder = pwd())\nomib_sys = System(joinpath(DATA_DIR, \"psse_raw/OMIB.raw\"),\n                     joinpath(DATA_DIR, \"psse_dyr/OMIB.dyr\"))","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"For more details about loading data and adding more dynamic components check the Creating a System with Dynamic devices section of the documentation in PowerSystems.jl.","category":"page"},{"location":"quick_start_guide/#Define-the-Simulation","page":"Quick Start Guide","title":"Define the Simulation","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"time_span = (0.0, 30.0)\nperturbation_trip = BranchTrip(1.0, \"BUS 1-BUS 2-i_1\")\nsim = Simulation(pwd(), omib_sys, time_span, perturbation_trip)","category":"page"},{"location":"quick_start_guide/#Explore-initial-conditions-for-the-simulation","page":"Quick Start Guide","title":"Explore initial conditions for the simulation","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"x0_init = get_initial_conditions(sim)","category":"page"},{"location":"quick_start_guide/#Obtain-small-signal-results-for-initial-conditions","page":"Quick Start Guide","title":"Obtain small signal results for initial conditions","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"    small_sig = small_signal_analysis(sim)","category":"page"},{"location":"quick_start_guide/#Execute-the-simulation","page":"Quick Start Guide","title":"Execute the simulation","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"    execute!(sim, IDA())","category":"page"},{"location":"quick_start_guide/#Make-a-plot-of-the-results","page":"Quick Start Guide","title":"Make a plot of the results","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"angle = get_state_series(sim, (\"generator-102-1\", :Î´));\nplot(angle, xlabel = \"time\", ylabel = \"rotor angle [rad]\", label = \"rotor angle\");\nsavefig(\"f-plot.svg\"); nothing # hide","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"(Image: plot)","category":"page"},{"location":"component_models/filters/#Filters","page":"Filter","title":"Filters","text":"","category":"section"},{"location":"component_models/filters/#LCL-Filter-[LCLFilter]","page":"Filter","title":"LCL Filter [LCLFilter]","text":"","category":"section"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"A standard LCL filter is proposed to connect the output of the converter to the grid. In this case, v_r and v_i are voltages in the capacitor, while v_r^textgrid and v_i^textgrid represent the voltage at the bus. The L filter after the capacitor can also include a step-up transformer to increase the voltage, that is model as an extra impedance.","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"beginalign\n    doti_rtextcv = fracOmega_bl_fleft( v_r^textcv - v_r  - r_f i_rtextcv + omega_textgrid l_f i_itextcv right) tag5a \n    doti_itextcv = fracOmega_bl_fleft( v_i^textcv - v_i  - r_f i_itextcv - omega_textgrid l_f i_rtextcv right) tag5b \n    dotv_r =  fracOmega_bc_fleft( i_r^textcv - i_r + omega_textgrid c_f v_i right) tag5c \n    dotv_i =  fracOmega_bc_fleft( i_i^textcv - i_i - omega_textgrid c_f v_r right) tag5d \n    doti_r = fracOmega_bl_gleft( v_r^textcv - v_r^textgrid - r_g i_r + omega_textgrid l_g i_itextcv right) tag5e \n    doti_i = fracOmega_bl_gleft( v_i^textcv - v_i^textgrid - r_g i_i - omega_textgrid l_g i_rtextcv right) tag5f\nendalign","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"on which","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"beginalign*\nv_r^textcv + jv_i^textcv = (v_d^textcv + jv_q^textcv)e^jdeltatheta_olc\nendalign*","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"that comes from the converter model.","category":"page"},{"location":"component_models/turbine_gov/#Prime-Movers-and-Turbine-Governors-(TG)","page":"Turbine and Governor","title":"Prime Movers and Turbine Governors (TG)","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This section describes how mechanical power is modified to provide primary frequency control with synchronous generators. It is assumed that tau_textref = P_textref since they are decided at nominal frequency omega = 1.","category":"page"},{"location":"component_models/turbine_gov/#Fixed-TG-[TGFixed]","page":"Turbine and Governor","title":"Fixed TG [TGFixed]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This a simple model that set the mechanical torque to be equal to a proportion of the desired reference tau_m = eta P_textref. To set the mechanical torque to be equal to the desired power, the value of eta is set to 1.","category":"page"},{"location":"component_models/turbine_gov/#TG-Type-I-[TGTypeI]","page":"Turbine and Governor","title":"TG Type I [TGTypeI]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This turbine governor is described by a droop controller and a low-pass filter to model the governor and two lead-lag blocks to model the servo and reheat of the turbine governor.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g1 = frac1T_s(p_textin - x_g1) tag13a \ndotx_g2 = frac1T_c left left(1- fract_3T_cright)x_g1 - x_g2 right tag13b \ndotx_g3 = frac1T_5 leftleft(1 - fracT_4T_5right)left(x_g2 + fracT_3T_cx_g1right) - x_g3  right tag13c \ntau_m = x_g3 + fracT_4T_5left(x_g2 + fracT_3T_cx_g1right) tag13d\nendalign","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"with","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign*\np_textin = P_textref + frac1R(omega_s - 1)\nendalign*","category":"page"},{"location":"component_models/turbine_gov/#TG-Type-II-[TGTypeII]","page":"Turbine and Governor","title":"TG Type II [TGTypeII]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This turbine governor is a simplified model of the Type I.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g = frac1T_2leftfrac1Rleft(1 - fracT_1T_2right) (omega_s - omega) - x_gright tag14a \ntau_m = P_textref + frac1RfracT_1T_2(omega_s - omega) tag14b\nendalign","category":"page"},{"location":"small/#Small-Signal-Analysis","page":"Small Signal","title":"Small Signal Analysis","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"Here we discuss the method used to do a small signal analysis on the DAE system defined in PowerSimulationsDynamics.jl. The package defines algebraic variables for both real and imaginary voltages on all buses (except if they have a dynamic line connected, on which the voltage of those buses are treated as differential variables). In addition, each dynamic device can add differential variables (or states) that are concatenated to construct the system of differential algebraic equations.","category":"page"},{"location":"small/#Automatic-Differentiation","page":"Small Signal","title":"Automatic Differentiation","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"Once an equilibrium point is found, the complete jacobian of the non-linear system can be obtained using automatic differentiation in Julia. In particular, the package ForwardDiff.jl is used to obtain the jacobian of the non-linear algebraic system of equations. PowerSimulationsDynamics.jl handles the resulting jacobian and reports the reduced jacobian and the corresponding eigenvalues and eigenvectors.","category":"page"},{"location":"small/#Jacobian-Reduction","page":"Small Signal","title":"Jacobian Reduction","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"We define y as the vector of algebraic variables, x as the vector of differential variables (states) and p the parameters of the system, we can define g(yxp) as the vector of algebraic equations and f(yxp) as the vector of differential equations. With that, the non-linear differential algebraic system of equations can be written as:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nleftbeginarrayc\n 0 \n  dotx\n  endarrayright = leftbeginarrayc\n  g(yxp) \n   f(yxp) endarrayright\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"For small signal analysis, we are interested in the stability around an equilbrium point y_eqx_eq that satisfies dotx = 0 or equivalently f(y_eqx_eqp) = 0, while obviously satisfying g(y_eq x_eq p) = 0. To do that we use a first order approximation:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nleftbeginarrayc\n 0 \n  Deltadotx\n  endarrayright = underbraceleftbeginarray\n  g(y_eqx_eqp) \n   f(y_eqx_eqp) endarrayright_ = 0\n + Jy_eq x_eq p leftbeginarrayc\n Delta y \n  Delta x\n  endarrayright\n  endalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"The first to note is that the jacobian matrix can be splitted in 4 blocks depending on the specific variables we are taking the partial derivatives:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nJy_eq x_eq p =\nleftbeginarraycc\n g_y  g_x \n f_y  f_x \n  endarrayright\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"For small signal analyses, we are interested in the stability of the differential states, while still considering that those need to evolve in the manifold defined by the linearized algebraic equations. Assuming that g_y is not singular (see chapter 7 of Federico Milano's book: \"Power System Modelling and Scripting\" or the following paper) we can eliminate the algebraic variables to obtain the reduced jacobian:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nJ_textred = f_x - f_y g_y^-1 g_x\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"that defines our reduced system for the differential variables","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nDelta dotx = J_textred Delta x\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"on which we can compute its eigenvalues to analyze local stability.","category":"page"},{"location":"component_models/freq_esti/#Frequency-Estimators","page":"Frequency Estimators","title":"Frequency Estimators","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"This component is used to estimate the frequency of the grid based on the voltage at the bus.","category":"page"},{"location":"component_models/freq_esti/#Phase-Locked-Loop-(PLL)-for-VSM-[KauraPLL]","page":"Frequency Estimators","title":"Phase-Locked Loop (PLL) for VSM [KauraPLL]","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"The following equations present a PLL used to estimate the frequency and PLL angle of the grid. There are two reference frames considered in this inverter. Those are the VSM of the outer-loop control deltatheta_textolc and the PLL one deltatheta_textpll. The notation used a deltatheta to refer as the variation of the respective angle theta with respect to the grid SRF (instead of the fixed alpha component of the alphabeta transformation):","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"beginalign\n\ndotv_dtextpll = omega_textlp left v_dtextout - v_dtextpll right tag1a \ndotv_qtextpll = omega_textlp left v_qtextout - v_qtextpll right tag1b \ndotvarepsilon_textpll = tan^-1left(fracv_qtextpllv_dtextpll right) tag1c \ndotdeltatheta_textpll = Omega_b delta omega_textpll tag1d\nendalign","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"with","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"beginalign\ndeltaomega_textpll = k_ptextpll tan^-1 left(fracv_qtextpllv_dtextpll right) + k_itextpll varepsilon_textpll tag1e \nv_dtextout + jv_qtextout = (v_r + jv_i)e^-deltatheta_textpll  tag1f\nendalign","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"on which v_r + jv_i is the voltage in the grid reference frame on which the PLL is measuring (i.e. point of common coupling), that could be in the capacitor of an LCL filter or the last branch of such filter.","category":"page"},{"location":"code_base_developer_guide/developer/#Guidelines-for-Developers","page":"Developer Guide","title":"Guidelines for Developers","text":"","category":"section"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to contribute to PowerSimulationsDynamics.jl repository please read the following sections of InfrastructureSystems.jl documentation in detail:","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"Style Guide\nContributing Guidelines","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"Pull requests are always welcome to fix bugs or add additional modeling capabilities.","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"All the code contributions need to include tests with a minimum coverage of 70%","category":"page"},{"location":"models/#Dynamic-Injection-Models","page":"Models","title":"Dynamic Injection Models","text":"","category":"section"},{"location":"models/#Generator-Models","page":"Models","title":"Generator Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Here we discuss the structure and models used to model generators in PowerSimulationsDynamics.jl. Each generator is a data structure that is defined by the following components:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Machine: That defines the stator electro-magnetic dynamics.\nShaft: That describes the rotor electro-mechanical dynamics.\nAutomatic Voltage Regulator: Electromotive dynamics to model an AVR controller.\nPower System Stabilizer: Control dynamics to define an stabilization signal for the AVR.\nPrime Mover and Turbine Governor: Thermo-mechanical dynamics and associated controllers.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The following figure summarizes the components of a generator and which variables they share:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"(Image: gen_meta)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Models are based from Federico Milano's book: \"Power System Modelling and Scripting\" and Prabha Kundur's book: \"Power System's Stability and Control\" and structures are defined in PowerSystems.jl.","category":"page"},{"location":"models/#Inverter-Models","page":"Models","title":"Inverter Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Here we discuss the structure and models used to model inverters in PowerSimulationsDynamics.jl. Each inverter is a data structure that is defined by the following components:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"DC Source: Defines the dynamics of the DC side of the converter.\nFrequency Estimator: That describes how the frequency of the grid can be estimated using the grid voltages. Typically a phase-locked loop (PLL).\nOuter Loop Control: That describes the active and reactive power control dynamics.\nInner Loop Control: That can describe virtual impedance, voltage control and current control dynamics.\nConverter: That describes the dynamics of the pulse width modulation (PWM) or space vector modulation (SVM).\nFilter: Used to connect the converter output to the grid.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The following figure summarizes the components of a inverter and which variables they share:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"(Image: inv_meta)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Contrary to the generator, there are many control structures that can be used to model inverter controllers (e.g. grid-following, grid feeding or virtual synchronous machine). For this purpose, more variables are shared among the components in order to cover all these posibilities.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Models are based from the paper: \"A Virtual Synchronous Machine implementation for distributed control of power converters in SmartGrids\" from S. D'Arco, J.A. Suul and O.B. Fosso, and structures are defined in PowerSystems.jl abbreviated as PSY.","category":"page"},{"location":"models/#Reference","page":"Models","title":"Reference","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"For constructors check the API on PowerSystems.jl documentation","category":"page"},{"location":"component_models/avr/#Automatic-Voltage-Regulators-(AVR)","page":"AVR","title":"Automatic Voltage Regulators (AVR)","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"AVR are used to determine the voltage in the field winding v_f in the model.","category":"page"},{"location":"component_models/avr/#Fixed-AVR-[AVRFixed]","page":"AVR","title":"Fixed AVR [AVRFixed]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This is a simple model that set the field voltage to be equal to a desired constant value v_f = v_textfix.","category":"page"},{"location":"component_models/avr/#Simple-AVR-[AVRSimple]","page":"AVR","title":"Simple AVR [AVRSimple]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This depicts the most basic AVR, on which the field voltage is an integrator over the difference of the measured voltage and a reference:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotv_f = K_v(v_textref - v_h) tag10a\nendalign","category":"page"},{"location":"component_models/avr/#AVR-Type-I-[AVRTypeI]","page":"AVR","title":"AVR Type I [AVRTypeI]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This AVR is a simplified version of the IEEE DC1 AVR model:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotv_f = -frac1T_e left V_f(K_e + S_e(v_f))-v_r1 right tag11a \ndotv_r1 = frac1T_a left K_aleft(v_textref - v_m - v_r2 - fracK_fT_fv_fright) - v_r1 right   tag11b \ndotv_r2 =  -frac1T_f left fracK_fT_fv_f + v_r2 right  tag11c \ndotv_m = frac1T_r (v_h - v_m) tag11d\nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with the ceiling function:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"component_models/avr/#AVR-Type-II-[AVRTypeII]","page":"AVR","title":"AVR Type II [AVRTypeII]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This model represents a static exciter with higher gains and faster response than the Type I:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotv_f = -frac1T_e left V_f(1 + S_e(v_f))-v_r right tag12a \ndotv_r1 = frac1T_1 left K_0left(1 - fracT_2T_1 right)(v_textref - v_m) - v_r1  right tag12b \ndotv_r2 =  frac1K_0 T_3 left left( 1 - fracT_4T_3 right) left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) - K_0 v_r2 right  tag12c \ndotv_m = frac1T_r (v_h - v_m) tag12d\nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nv_r = K_0v_r2 + fracT_4T_3 left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) \nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"component_models/outer_control/#Outer-Loop-Controls","page":"Outer Control","title":"Outer Loop Controls","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"This component defines controllers for both active and reactive power. The joint design is based on the fact that many novel control techniques can be based on joint control of active and reactive power.","category":"page"},{"location":"component_models/outer_control/#Virtual-Inertia-and-Q-droop-[OuterControl]","page":"Outer Control","title":"Virtual Inertia and Q-droop [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represent a virtual synchronous machine model to represent how active power is going to be deployed. The constructor is OuterControl{VirtualInertia, ReactivePowerDroop}. It defines a new SRF denoted as theta_textolc for the active power controller and uses a simple voltage droop for dispatching reactive power:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotdeltaomega_textolc = fracp_textrefT_a - fracp_eT_a - frack_d(omega_textolc - omega_textpll)T_a - frack_omega(omega_textolc - omega_textref)T_a tag2a \n    dotdeltatheta_textolc = Omega_b deltaomega_textolc tag2b \n    dotq_m = omega_f (q_e - q_m) tag2c\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    p_e = v_ri_r + v_ii_i tag2d \n    q_e = v_ii_r - v_ri_i tag2e \n    v_textolc^textref = v_textref + k_q(q_textref - q_m) tag2f\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In this case, the measurement of power are being done in the capacitor of the LCL filter. However, depending on the model, this measurements could be different depending on where is the point of common coupling.","category":"page"},{"location":"component_models/machines/#Machines","page":"Machine","title":"Machines","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The machine component describes the stator-rotor electromagnetic dynamics.","category":"page"},{"location":"component_models/machines/#Classical-Model-(Zero-Order)-[BaseMachine]","page":"Machine","title":"Classical Model (Zero Order) [BaseMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This is the classical order model that does not have differential equations in its machine model (delta and omega are defined in the shaft):","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_d  x_d  r_a endarray right^-1  left beginarrayc -v_d  e_q - v_q endarray right tag1a\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag1b\nendalign","category":"page"},{"location":"component_models/machines/#One-d-One-q-Model-(2th-Order)-[OneDOneQMachine]","page":"Machine","title":"One d- One q- Model (2th Order) [OneDOneQMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model includes two transient emf with their respective differential equations:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 left-e_q + (x_d-x_d)i_d + v_fright tag2a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag2b\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag2c\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag2d\nendalign","category":"page"},{"location":"component_models/machines/#Marconato-Machine-(6th-Order)-[MarconatoMachine]","page":"Machine","title":"Marconato Machine (6th Order) [MarconatoMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The Marconato model defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag3a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag3b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag3c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag3d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag3e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag3f \ni_d = frac1x_d (e_q - psi_d) tag3g \ni_q = frac1x_q (-e_d - psi_q) tag3h \ntau_e = psi_d i_q - psi_q i_d tag3i\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"component_models/machines/#Simplified-Marconato-Machine-(4th-Order)-[SimpleMarconatoMachine]","page":"Machine","title":"Simplified Marconato Machine (4th Order) [SimpleMarconatoMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omegapsi_d=psi_d and omegapsi_q=psi_q) that allows to remove the stator fluxes variables from the Marconato model.","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag4a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag4b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag4c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag4d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag4e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag4f\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"component_models/machines/#Anderson-Fouad-Machine-(6th-Order)-[AndersonFouadMachine]","page":"Machine","title":"Anderson-Fouad Machine (6th Order) [AndersonFouadMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The Anderson-Fouad model also defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs and is derived from the Marconato model by defining gamma_d approx gamma_q approx T_AA approx 0:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag5a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag5b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag5c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag5d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag5e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag5f \ni_d = frac1x_d (e_q - psi_d) tag5g \ni_q = frac1x_q (-e_d - psi_q) tag5h \ntau_e = psi_d i_q - psi_q i_d tag5i\nendalign","category":"page"},{"location":"component_models/machines/#Simplified-Anderson-Fouad-Machine-(4th-Order)-[SimpleAFMachine]","page":"Machine","title":"Simplified Anderson-Fouad Machine (4th Order) [SimpleAFMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"Similar to the Simplified Marconato Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omega psi_d = psi_d and omega psi_q = psi_q) that allows to remove the stator fluxes variables from the model:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag6a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag6b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag6c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag6d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag6e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag6f\nendalign","category":"page"},{"location":"component_models/machines/#Round-Rotor-Machine-(4th-Order)-[RoundRotorQuadratic,-RoundRotorExponential]","page":"Machine","title":"Round Rotor Machine (4th Order) [RoundRotorQuadratic, RoundRotorExponential]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model represents the traditional round rotor models GENROU/GENROE models implemented in PSLF/PSSE/PowerWorld. Similar to the Simplified Marconato Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q). Round rotor machines must satisfy x_d = x_q.","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 leftv_f - X_adI_fdright tag7a\ndote_d = frac1T_q0 left-X_aqI_1q right tag7b\ndotpsi_kd = frac1T_d0 left-psi_kd + e_q - (x_d-x_l)i_d right tag7c \ndotpsi_kq = frac1T_q0 left-psi_kq + e_d + (x_q-x_l)i_q right tag7d \nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ngamma_d1 = fracx_d - x_lx_d - x_l tag7e\ngamma_q1 = fracx_q - x_lx_q - x_l tag7f\ngamma_d2 = fracx_d - x_d(x_d-x_l)^2 tag7g\ngamma_q2 = fracx_q - x_q(x_q - x_l)^2 tag7h\ngamma_qd = fracx_q - x_lx_d - x_l tag7i\npsi_q = gamma_q1 e_d + psi_kq (1 - gamma_q1) tag7j\npsi_d = gamma_d1 e_q + gamma_d2 (x_d - x_l) psi_kd tag7k\npsi = sqrt(psi_d)^2 + (psi_q)^2 tag7l\nleft beginarrayc i_d  i_q endarray right = left beginarraycc -r_a  x_q  -x_d  r_a endarray right^-1  left beginarrayc v_d - psi_q  -v_q + psi_d endarray right tag7m\nX_adI_fd = e_q + (x_d - x_d) (gamma_d1 i_d - gamma_d2 psi_kd + gamma_d2 + e_q) + textSe(psi) psi_d tag7n\nX_aqI_1q = e_d + (x_q - x_q) (gamma_q2 e_d - gamma_q2psi_kq - gamma_q1 i_q) + textSe(psi) psi_q gamma_qd tag7o \ntau_e = i_d (r_a i_d + v_d) + i_q(r_a i_q + v_q) tag7p\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The difference between GENROU and GENROE occurs in which additive saturation function textSe(psi) is used. Input data is provided by the saturation values at psi = 10 and psi = 12 p.u. For the GENROU model, the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(psi) = fracB(psi - A)^2 psi tag7q\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"and for the GENROE model the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(psi) = B(psi)^A tag7r\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The parameters A and B for each function are computed using the two points given (10 textSe(10)) and (12 textSe(12)).","category":"page"},{"location":"component_models/shafts/#Shafts","page":"Shaft","title":"Shafts","text":"","category":"section"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"The shaft component defines the rotating mass of the synchronous generator.","category":"page"},{"location":"component_models/shafts/#Rotor-Mass-Shaft-[SingleMass]","page":"Shaft","title":"Rotor Mass Shaft [SingleMass]","text":"","category":"section"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"This is the standard model, on which one single mass (typically the rotor) is used to model the entire inertia of the synchronous generator. Each generator's rotating frame use a reference frequency omega_s, that typically is the synchronous one (i.e. omega_s = 10). The model defines two differential equations for the rotor angle delta and the rotor speed omega:","category":"page"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag8a \ndotomega = frac12H(tau_m - tau_e - D(omega-omega_s)) tag8b\nendalign","category":"page"},{"location":"component_models/shafts/#Five-Mass-Shaft-[FiveMassShaft]","page":"Shaft","title":"Five-Mass Shaft [FiveMassShaft]","text":"","category":"section"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"This model describes model connecting a high-pressure (hp) steam turbine, intermediate-pressure (ip) steam turbine, low-pressure (lp) steam pressure, rotor and exciter (ex) connected in series (in that order) in the same shaft using a spring-mass model:","category":"page"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag9a \ndotomega = frac12H left- tau_e - D(omega-omega_s)) - D_34 (omega-omega_lp) - D_45(omega-omega_ex) + K_lp(delta_lp-delta) +K_ex(delta_ex-delta) right tag9b \ndotdelta_hp = Omega_b(omega_hp - omega_s) tag9c \ndotomega_hp = frac12H_hp left tau_m - D_hp(omega_hp-omega_s) - D_12(omega_hp - omega_ip) + K_hp(delta_ip - delta_hp) right tag9d \ndotdelta_ip = Omega_b(omega_ip - omega_s) tag9e \ndotomega_ip = frac12H_ip left- D_ip(omega_ip-omega_s) - D_12(omega_ip - omega_hp) -D_23(omega_ip - omega_lp ) + K_hp(delta_hp - delta_ip) + K_ip(delta_lp-delta_ip) right tag9f \ndotdelta_lp = Omega_b(omega_lp-omega_s) tag9g \ndotomega_lp = frac12H_lp left - D_lp(omega_lp-omega_s) - D_23(omega_lp - omega_ip) -D_34(omega_lp - omega ) + K_ip(delta_ip - delta_lp) + K_lp(delta-delta_lp) right tag9h \ndotdelta_ex = Omega_b(omega_ex-omega_s) tag9i \ndotomega_ex = frac12H_ex left - D_ex(omega_ex-omega_s) - D_45(omega_ex - omega) + K_ex(delta - delta_ex) right tag9j\nendalign","category":"page"},{"location":"api/public/#PowerSimulationsDynamics","page":"Public API Reference","title":"PowerSimulationsDynamics","text":"","category":"section"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"CurrentModule = PowerSimulationsDynamics\nDocTestSetup  = quote\n    using PowerSimulationsDynamics\nend","category":"page"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [PowerSimulationsDynamics]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/public/#PowerSimulationsDynamics.BranchTrip","page":"Public API Reference","title":"PowerSimulationsDynamics.BranchTrip","text":"Use to model the trip of an AC Branch in in the system. Accepts lines or transformer lines\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.ControlReferenceChange","page":"Public API Reference","title":"PowerSimulationsDynamics.ControlReferenceChange","text":"Use to model control reference changes in devices of the model\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.NetworkSwitch","page":"Public API Reference","title":"PowerSimulationsDynamics.NetworkSwitch","text":"Use to model a change in the network by switching the underlying Ybus in the simulation\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.Simulation","page":"Public API Reference","title":"PowerSimulationsDynamics.Simulation","text":"Initializes the simulations and builds the indexing. The input system is not modified during the initialization\n\nAccepted Key Words\n\ninitialize_simulation::Bool : Runs the initialization routine. If false, simulation runs based on the operation point stored in System\nsystem_to_file::Bool: Serializes the original input system\nconsole_level::Logging: Sets the level of logging output to the console. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debugg\nfile_level::Logging: Sets the level of logging output to file. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.Simulation!","page":"Public API Reference","title":"PowerSimulationsDynamics.Simulation!","text":"Builds the simulation object and conducts the indexing process. The initial conditions are stored in the system.\n\nAccepted Key Words\n\ninitialize_simulation::Bool : Runs the initialization routine. If false, simulation runs based on the operation point stored in System\nsystem_to_file::Bool: Serializes the initialized system\nconsole_level::Logging: Sets the level of logging output to the console. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\nfile_level::Logging: Sets the level of logging output to file. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\n\n\n\n\n\n","category":"function"},{"location":"api/public/#PowerSimulationsDynamics.get_initial_conditions-Tuple{Simulation}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_initial_conditions","text":"Returns a Dictionary with the resulting initial conditions of the simulation\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_state_series-Tuple{Simulation,Tuple{String,Symbol}}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_state_series","text":"Function to obtain series of states out of DAE Solution. It receives the solution, the dynamical system and a tuple containing the symbol name of the Dynamic Injection device and the symbol of the state.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_voltagemag_series-Tuple{Simulation,Int64}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_voltagemag_series","text":"Function to obtain the voltage magnitude series out of the DAE Solution. It receives the solution, the dynamical system and the bus number.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.print_device_states-Tuple{Simulation}","page":"Public API Reference","title":"PowerSimulationsDynamics.print_device_states","text":"Function to print initial states. It receives the vector of initial states and the dynamical system.\n\n\n\n\n\n","category":"method"},{"location":"component_models/network/#Network-model","page":"Network","title":"Network model","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Here we discuss the models used to describe the network in PowerSimulationsDynamics.jl. This is based on a standard current injection model as defined in Federico Milano's book: Power System Modelling and Scripting. The numerical advantages of current injection models outweigh the complexities of implementing constant power loads for longer-term transient stability analysis. The network is defined in a synchronous reference frame (SRF), named the RI (real-imaginary) reference frame, rotating at the constant base frequency Omega_b.","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"In simple terms, PowerSimulationsDynamics.jl internally tracks the current-injection balances at the nodal level from all the devices on the system. Based on the buses and branches information, the system constructor computes the admittance matrix boldsymbolY assuming nominal frequency and this is used for static branch modeling. The algebraic equations for the static portions of the network are as follows:","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":" beginalign\n 0 = boldsymboli(boldsymbolx boldsymbolv) - boldsymbolYboldsymbolx\n endalign","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"where boldsymboli is the vector of the sum of complex current injections from devices, boldsymbolx is the vector of states and boldsymbolv is the vector of complex bus voltages. Equations (1) connect all the port variables, i.e., currents, defined for each injection device. Components that contribute to (1) by modifying the current boldsymboli are (i) static injection devices, (ii) dynamic injection devices, and (iii) dynamic network branches. Components that contribute to modify the admittance matrix boldsymbolY are static branches.","category":"page"},{"location":"component_models/network/#Static-Branches-(or-Algebraic-Branches)","page":"Network","title":"Static Branches (or Algebraic Branches)","text":"","category":"section"},{"location":"component_models/network/#Lines","page":"Network","title":"Lines","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Each line is defined using a pi model connecting two buses (nm), with a series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m). The values are already in system per unit. Then each branch contributes to the admittance matrix as follows:","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"beginalign\nY_nn += frac1r+jx + jc_n \nY_nm += frac-1r+jx \nY_mm += frac1r+jx + jc_m \nY_mn += frac-1r+jx \nendalign","category":"page"},{"location":"component_models/network/#Two-Windings-Transformers","page":"Network","title":"Two-Windings Transformers","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Similarly to lines these are defined by a series reactance and impedance. The equations are equivalently of the lines without the shunt capacitance.","category":"page"},{"location":"component_models/network/#Dynamic-Branches","page":"Network","title":"Dynamic Branches","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Dynamic network branches contribute directly to (1) by modifying the vector of complex currents. Their parameters are also the series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m) for a line ell. In addition, they define 3 new additional differential equations per line (6 in total for real and imaginary part):","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"beginalign\n    fraclOmega_b fracdi_elldt = (v_n - v_m) - (r+jl) i_ell \n     fracc_nOmega_b fracdv_ndt =  i_n^textcap - jc_nv_n   \n      fracc_mOmega_b fracdv_mdt = i_m^textcap - jc_mv_m\nendalign","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Since all the values are in per unit, the reactance is equal to the inductance.","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"A detail discussion about the effects of different line models in the modeling of inverters is presented in Grid Forming Inverter Small Signal Stability: Examining Role of Line and Voltage Dynamics","category":"page"},{"location":"component_models/pss/#Power-System-Stabilizers-(PSS)","page":"PSS","title":"Power System Stabilizers (PSS)","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"PSS are used to add an additional signal v_s to the field voltage: v_f = v_f^textavr + v_s.","category":"page"},{"location":"component_models/pss/#Fixed-PSS-[PSSFixed]","page":"PSS","title":"Fixed PSS [PSSFixed]","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"This is a simple model that set the stabilization signal to be equal to a desired constant value v_s = v_s^textfix. The absence of PSS can be modelled using this component with v_s^textfix = 0.","category":"page"},{"location":"component_models/pss/#Simple-PSS-[PSSSimple]","page":"PSS","title":"Simple PSS [PSSSimple]","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"This is the most basic PSS that can be implemented, on which the stabilization signal is  a proportional controller over the frequency and electrical power:","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"beginalign\nv_s = K_omega(omega - omega_s) + K_p(omega tau_e - P_textref) tag12a\nendalign","category":"page"},{"location":"tutorials_page/#SIIP-Examples","page":"Tutorials","title":"SIIP-Examples","text":"","category":"section"},{"location":"tutorials_page/","page":"Tutorials","title":"Tutorials","text":"All the tutorials for the SIIP project are part of a separate repository SIIP-Examples. You can access the latest PowerSimulationsDynamics.jl tutorial notebooks in this link","category":"page"},{"location":"tutorials_page/","page":"Tutorials","title":"Tutorials","text":"Specific examples of common workflows and models:","category":"page"},{"location":"tutorials_page/","page":"Tutorials","title":"Tutorials","text":"Loading Dynamic Data\nSolving a One Machine against Infinite Bus model\nChanging line modeling assumptions\nUsing an Inverter in a Multi-Machine Model","category":"page"},{"location":"reference_frames/#Reference-Frames","page":"Reference Frames","title":"Reference Frames","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"Each dynamic device is defined in its own dq synchronous reference frame (SRF). It is important to note that there are several conventions to do reference frame transformations.","category":"page"},{"location":"reference_frames/#Synchronous-Machines","page":"Reference Frames","title":"Synchronous Machines","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"The grid is modeled in its own real-imaginary (RI) reference frame. With such, this follows the standard convention that for a voltage angle theta = 0, there is no imaginary part and hence v_h = v_r + j0. Traditionally, the reference frame dq with rotor angle delta for synchronous machines connected to a bus v_hangle theta = v_r + jv_i follows the following convention for transformation of per-unit RMS phasors:","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"beginalign\nv_d + jv_q = (v_r + jv_i) e^-(delta- pi2) tag1a \nv_d =  v_h sin(delta - theta) tag1b \nv_q = v_h cos(delta - theta) tag1c \nleft beginarrayc v_d  v_q endarray right = left beginarraycc sin(delta)  -cos(delta)  cos(delta)  sin(delta) endarray right left beginarrayc v_r  v_i endarray right tag1d\nendalign","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"Note that hence in a bus of 10angle 0, a rotor angle of delta = 0 implies that v_q = 10 and v_d = 00. This transformation is the one that can be found in most books of Power Systems, such as Kundur, Sauer Pai and in Milano too, and is the convention used in the software to model dynamic models of synchronous machines in their own reference frame.","category":"page"},{"location":"reference_frames/#Inverters","page":"Reference Frames","title":"Inverters","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"The previously convention is not the standard one used for modeling inverters. Most of inverter and phase-lock loop (PLL) models follow the next convention:","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"beginalign\nv_d + jv_q = (v_r + jv_i) e^-delta tag2a  \nv_d =  v_h cos(delta - theta) tag2b \nv_q = -v_h sin(delta - theta) tag2c\nendalign","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"That, contrary to the previous case, when delta = theta = 0 implies that v_d = 10 and v_q = 00. This yields the typical PLL conditions that steer v_q to 0 when delta locks in theta, or when both SRF lock between each other.","category":"page"},{"location":"reference_frames/#Transformation-used","page":"Reference Frames","title":"Transformation used","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"Given the predominancy of both convention in current work, the software uses both conventions depending on the device modeled. For synchronous machines we used the standard convention (1a)-(1d), while for inverter models we use the predominant convention used nowadays in such models, i.e. (2a)-(2c).","category":"page"},{"location":"component_models/dc_source/#DC-Source","page":"DC Sources","title":"DC Source","text":"","category":"section"},{"location":"component_models/dc_source/","page":"DC Sources","title":"DC Sources","text":"This component can be used to model the dynamics of the DC side of the converter.","category":"page"},{"location":"component_models/dc_source/#Fixed-DC-Source-[FixedDCSource]","page":"DC Sources","title":"Fixed DC Source [FixedDCSource]","text":"","category":"section"},{"location":"component_models/dc_source/","page":"DC Sources","title":"DC Sources","text":"This is a model that set the DC voltage to a fixed value v_textdc = v_textdc^textfix.","category":"page"},{"location":"api/internal/#Internal","page":"Internal API Reference","title":"Internal","text":"","category":"section"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"CurrentModule = PowerSimulationsDynamics\nDocTestSetup  = quote\n    using PowerSimulationsDynamics\nend","category":"page"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [PowerSimulationsDynamics]\nPublic = false\nPrivate = true","category":"page"},{"location":"api/internal/#PowerSimulationsDynamics.BUILD_STATUS","page":"Internal API Reference","title":"PowerSimulationsDynamics.BUILD_STATUS","text":"Defines the status of the simulation object\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.generator_inner_vars","page":"Internal API Reference","title":"PowerSimulationsDynamics.generator_inner_vars","text":"Generator Inner Vars:\n\nÏe_var :: Electric torque\nÏm_var :: Mechanical torque\nVf_var :: Field voltage\nVpssvar :: Additional PSS voltage\nVRgenvar :: Real part of the terminal voltage\nVIgenvar :: Imaginary part of the terminal voltage\nÏd_var :: Stator Flux (if defined) in the d-axis\nÏq_var :: Stator Flux (if defined) in the q-axis\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.inverter_inner_vars","page":"Internal API Reference","title":"PowerSimulationsDynamics.inverter_inner_vars","text":"Inverter Inner Vars: @enum inverterinnervars begin mdvar :: Modulation signal on the d-component mqvar :: Modulation signal on the q-component Vdcvar :: DC voltage supplied by the DC source Vrfiltervar :: Voltage seen in the capacitor of the filter in the R-component Vifiltervar :: Voltage seen in the capacitor of the filter in the I-component Ïfreqestimatorvar :: Frequency estimated by the frequency estimator. Vocvar :: Control voltage supplied from the outer loop control to the inner loop Ïocvar :: Control frequency supplied from the outer loop control the inner loop Î¸ocvar :: Variation of the angle (PLL or VSM) of the inverter VRinvvar :: Real terminal voltage on the inverter VIinvvar :: Imaginary terminal voltage on the inverter Vrcnvvar :: Voltage supplied from the converter in the R-component Vicnvvar :: Voltage supplied from the converter in the I-component\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.configure_logging-Tuple{}","page":"Internal API Reference","title":"PowerSimulationsDynamics.configure_logging","text":"configure_logging(;\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\",\n)\n\nCreates console and file loggers.\n\nNote: Log messages may not be written to the file until flush() or close() is called on the returned logger.\n\nArguments\n\nconsole_level = Logging.Error: level for console messages\nfile_level = Logging.Info: level for file messages\nfilename::String = power-simulations.log: log file\n\nExample\n\nlogger = configure_logging(console_level = Logging.Info)\n@info \"log message\"\nclose(logger)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,StaticInjection,DynamicGenerator{AndersonFouadMachine,S,A,TG,P}}} where P<:PSS where TG<:TurbineGov where A<:AVR where S<:Shaft","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 6-state (Anderson-Fouad) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,StaticInjection,DynamicGenerator{BaseMachine,S,A,TG,P}}} where P<:PSS where TG<:TurbineGov where A<:AVR where S<:Shaft","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 0-state synchronous (classic model) machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,StaticInjection,DynamicGenerator{MarconatoMachine,S,A,TG,P}}} where P<:PSS where TG<:TurbineGov where A<:AVR where S<:Shaft","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 6-state (Marconato) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,StaticInjection,DynamicGenerator{OneDOneQMachine,S,A,TG,P}}} where P<:PSS where TG<:TurbineGov where A<:AVR where S<:Shaft","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 2-state (One d- and One q-) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,StaticInjection,DynamicGenerator{SimpleAFMachine,S,A,TG,P}}} where P<:PSS where TG<:TurbineGov where A<:AVR where S<:Shaft","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 4-state (Simple Anderson-Fouad) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,StaticInjection,DynamicGenerator{SimpleMarconatoMachine,S,A,TG,P}}} where P<:PSS where TG<:TurbineGov where A<:AVR where S<:Shaft","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 4-state (Simple Marconato) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.kirchoff_laws!-Tuple{PowerSimulationsDynamics.SimulationInputs,Any,Any,Any,Any,Any}","page":"Internal API Reference","title":"PowerSimulationsDynamics.kirchoff_laws!","text":"Kirchoff law for buses.\nI_gen_r[j]: Real current injection from all generators connected at bus j.\n            It is zero if no generator is connected at bus j.\nI_gen_i[j]: Real current injection from all generators connected at bus j.\n            It is zero if no generator is connected at bus j.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.make_device_index!-Tuple{StaticInjection}","page":"Internal API Reference","title":"PowerSimulationsDynamics.make_device_index!","text":"Indexes the devices states and maps to the ports\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,Any,Any,Any,Float64,Float64,DynamicGenerator{AndersonFouadMachine,S,A,TG,P}}} where P<:PSS where TG<:TurbineGov where A<:AVR where S<:Shaft","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 6-state (AndersonFouadMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,Any,Any,Any,Float64,Float64,DynamicGenerator{BaseMachine,S,A,TG,P}}} where P<:PSS where TG<:TurbineGov where A<:AVR where S<:Shaft","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 0-state synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,Any,Any,Any,Float64,Float64,DynamicGenerator{MarconatoMachine,S,A,TG,P}}} where P<:PSS where TG<:TurbineGov where A<:AVR where S<:Shaft","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 6-state (MarconatoMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,Any,Any,Any,Float64,Float64,DynamicGenerator{OneDOneQMachine,S,A,TG,P}}} where P<:PSS where TG<:TurbineGov where A<:AVR where S<:Shaft","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 2-state (One d- and One q-) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,Any,Any,Any,Float64,Float64,DynamicGenerator{SimpleAFMachine,S,A,TG,P}}} where P<:PSS where TG<:TurbineGov where A<:AVR where S<:Shaft","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 4-state (SimpleAFMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,Any,Any,Any,Float64,Float64,DynamicGenerator{SimpleMarconatoMachine,S,A,TG,P}}} where P<:PSS where TG<:TurbineGov where A<:AVR where S<:Shaft","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 4-state (SimpleMarconatoMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.saturation_function-Tuple{Union{RoundRotorExponential, SalientPoleExponential},Number}","page":"Internal API Reference","title":"PowerSimulationsDynamics.saturation_function","text":"Saturation function for exponential saturation models for machines\n    Se(x) = B * x^A\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.saturation_function-Tuple{Union{RoundRotorQuadratic, SalientPoleQuadratic},Number}","page":"Internal API Reference","title":"PowerSimulationsDynamics.saturation_function","text":"Saturation function for quadratic saturation models for machines\n    Se(x) = B * (x - A)^2 / x\n\n\n\n\n\n","category":"method"},{"location":"component_models/converter/#Converter","page":"Converter","title":"Converter","text":"","category":"section"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"This component can be used to model the dynamics of the switching process.","category":"page"},{"location":"component_models/converter/#Average-Model-[AverageConverter]","page":"Converter","title":"Average Model [AverageConverter]","text":"","category":"section"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"The average model outputs the desired reference signal since:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign\nv_d^textcv approx m_d v_textdc approx fracv_d^textref-signalv_textdc v_textdc approx v_d^textref-signal tag4a \nv_q^textcv approx m_q v_textdc approx fracv_q^textref-signalv_textdc v_textdc approx v_q^textref-signal tag4b\nendalign","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"where m_dq is the modulation signal, and v_dq^textref-signal is the voltage reference signal from the inner loop control.","category":"page"},{"location":"#PowerSimulationsDynamics.jl","page":"Welcome Page","title":"PowerSimulationsDynamics.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = PowerSystems","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulationsDynamics.jl is a Julia package for doing Power Systems Dynamic Modeling with Low Inertia Energy Sources.","category":"page"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The latest stable release of PowerSimulationsDynamics can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerSimulationsDynamics","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerSimulationsDynamics#master","category":"page"},{"location":"#Structure","page":"Welcome Page","title":"Structure","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The following figure shows the interactions between PowerSimulationsDynamics.jl, PowerSystems.jl, DifferentialEquations.jl and the integrators. The architecture of PowerSimulationsDynamics.jl  is such that the power system models are all self-contained and return the model function evaluations. The Jacobian is calculated through DifferentialEquations.jl's common-interface enabling the use of any solver available in Julia. Considering that the resulting models are differential-algebraic equations (DAE), the implementation focuses on the use of implicit solvers, in particular SUNDIALS since it has exceptional features applicable to large models â for instance, interfacing with distributed linear-solvers and GPU arrays. In addition, automatic differentiation is implemented using ForwardDiff.jl to obtain jacobians to perform small signal analysis.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"<img src=\"./assets/SoftwareLoop.png\" width=\"65%\"/>","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"â ","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulationsDynamics has been developed as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (NREL)","category":"page"}]
}
