var documenterSearchIndex = {"docs":
[{"location":"component_models/inner_control/#Inner-Loop-Controls","page":"Inner Control","title":"Inner Loop Controls","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"This component defines voltage and current controllers to generate the reference signal for the converter. Although in many controls the current and voltage control are separate blocks we propose a more general control approach that considers them as a joint control logic.","category":"page"},{"location":"component_models/inner_control/#Integrated-Virtual-Impedance,-Voltage-and-Current-Controller-[VoltageModeControl]","page":"Inner Control","title":"Integrated Virtual Impedance, Voltage and Current Controller [VoltageModeControl]","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"The following model receives both the outer loop control frequency and reference voltage signal to generate the reference signal for the converters. The virtual impedance plays a similar role of the impedance of a synchronous generator. A PI voltage controller is used to generate the current signal that is used in the PI current controller to finally generate the voltage reference signal for the converters.","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\n    dotxi_d = v_dtextvi^textref - v_d tag1a \n    dotxi_q = v_qtextvi^textref - v_q tag1b \n    dotgamma_d = i_dtextcv^textref - i_dtextcv tag1c \n    dotgamma_q = i_qtextcv^textref - i_qtextcv tag1d \n    dotphi_d = omega_textad(v_d - phi_d) tag1e \n    dotphi_q = omega_textad(v_q - phi_q) tag1f\nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"with","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    v_dtextvi^textref = v_textolc^textref - r_v i_d + omega_textolc l_v i_q tag1g \n    v_qtextvi^textref = - r_v i_q - omega_textolc l_v i_d tag1h \n    i_dtextcv^textref = k_pvleft(v_dtextvi^textref - v_dright) + k_iv xi_d - c_f omega_textolc v_q + k_textffii_d tag1i \n    i_qtextcv^textref = k_pvleft(v_qtextvi^textref - v_qright) + k_iv xi_q + c_f omega_textolc v_d + k_textffii_q tag1j \n    v_d^textref-signal = k_pc left(i_dtextcv^textref - i_dtextcvright) + k_ic gamma_d - omega_textolc l_f i_qtextcv + k_textffvv_d - k_textad(v_d - phi_d) tag1k \n    v_q^textref-signal = k_pc left(i_qtextcv^textref - i_qtextcvright) + k_ic gamma_q + omega_textolc l_f i_dtextcv + k_textffvv_q - k_textad(v_q - phi_q) tag1l\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"In here the transformation to the dq reference frame is using the outer-loop reference angle as:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\nv_d + jv_q = (v_r + jv_i)e^-jdeltatheta_olc \ni_d + ji_q = (i_r + ji_i)e^-jdeltatheta_olc\nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"that again v_r + jv_i could be in the capacitor or the last branch of the filter (i.e. the point of common coupling). For LCL filters it is considered in the capacitor. In the case of the converter, the transformation is directly","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\ni_dtextcv + ji_qtextcv = (i_rtextcv + ji_itextcv)e^-jdeltatheta_olc\nendalign*","category":"page"},{"location":"component_models/inner_control/#Current-Mode-Controller-[CurrentModeControl]","page":"Inner Control","title":"Current Mode Controller [CurrentModeControl]","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"The following model receives the current reference (in dq axis) from an outer loop controller that outputs current references such as the PI outer controller used for grid following inverters. A PI current controller is used to generate the voltage reference signal for the converters.","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\n    dotgamma_d = i_dtextcv^textref - i_dtextcv tag2a \n    dotgamma_q = i_qtextcv^textref - i_qtextcv tag2b \nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"with","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    v_d^textref-signal = k_pc left(i_dtextcv^textref - i_dtextcvright) + k_ic gamma_d - omega_textolc l_f i_qtextcv + k_textffvv_d tag2b \n    v_q^textref-signal = k_pc left(i_qtextcv^textref - i_qtextcvright) + k_ic gamma_q + omega_textolc l_f i_dtextcv + k_textffvv_q tag2c\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"The transformation for the converter current is computed as:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\ni_dtextcv + ji_qtextcv = (i_rtextcv + ji_itextcv)e^-jtheta_olc\nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"In here theta_olc is the outer-loop angle. In the case of grid-following models, this angle is equal to the angle provided from the PLL.","category":"page"},{"location":"quick_start_guide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"You can access example data in the Power Systems Test Data Repository, the data can be downloaded with the PowerSystems.jl submodule UtilsData.","category":"page"},{"location":"quick_start_guide/#Loading-data","page":"Quick Start Guide","title":"Loading data","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Data can be loaded from a pss/e raw file and a pss/e dyr file.","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"using PowerSystems, PowerSimulationsDynamics, Sundials, Plots, Logging\nlogger = configure_logging(console_level = Logging.Error, file_level = Logging.Info)\nDATA_DIR = download(PowerSystems.UtilsData.TestData, folder = pwd())\nomib_sys = System(joinpath(DATA_DIR, \"psse_raw/OMIB.raw\"),\n                     joinpath(DATA_DIR, \"psse_dyr/OMIB.dyr\");\n                     time_series_in_memory = true)","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"For more details about loading data and adding more dynamic components check the Creating a System with Dynamic devices section of the documentation in PowerSystems.jl.","category":"page"},{"location":"quick_start_guide/#Define-the-Simulation","page":"Quick Start Guide","title":"Define the Simulation","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"time_span = (0.0, 30.0)\nperturbation_trip = BranchTrip(1.0, \"BUS 1-BUS 2-i_1\")\nsim = Simulation!(ImplicitModel, omib_sys, pwd(), time_span, perturbation_trip)","category":"page"},{"location":"quick_start_guide/#Explore-initial-conditions-for-the-simulation","page":"Quick Start Guide","title":"Explore initial conditions for the simulation","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"x0_init = get_initial_conditions(sim)","category":"page"},{"location":"quick_start_guide/#Obtain-small-signal-results-for-initial-conditions","page":"Quick Start Guide","title":"Obtain small signal results for initial conditions","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"    small_sig = small_signal_analysis(sim)","category":"page"},{"location":"quick_start_guide/#Execute-the-simulation","page":"Quick Start Guide","title":"Execute the simulation","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"    execute!(sim, IDA())","category":"page"},{"location":"quick_start_guide/#Make-a-plot-of-the-results","page":"Quick Start Guide","title":"Make a plot of the results","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"angle = get_state_series(sim, (\"generator-102-1\", :Î´));\nplot(angle, xlabel = \"time\", ylabel = \"rotor angle [rad]\", label = \"gen-102-1\");","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"(Image: plot)","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"If you miss PSS/e's plotting aesthetics and want something that resembles that, you can use UnicodePlots.","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"using UnicodePlots\nunicodeplots()\nplot(angle, xlabel = \"time\", ylabel = \"rotor angle [rad]\", label = \"gen-102-1\");","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"(Image: plot)","category":"page"},{"location":"component_models/filters/#Filters","page":"Filter","title":"Filters","text":"","category":"section"},{"location":"component_models/filters/#LCL-Filter-[LCLFilter]","page":"Filter","title":"LCL Filter [LCLFilter]","text":"","category":"section"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"A standard LCL filter is proposed to connect the output of the converter to the grid. In this case, v_r and v_i are voltages in the capacitor, while v_r^textgrid and v_i^textgrid represent the voltage at the bus. The L filter after the capacitor can also include a step-up transformer to increase the voltage, that is model as an extra impedance.","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"beginalign\n    doti_rtextcv = fracOmega_bl_fleft( v_r^textcv - v_r  - r_f i_rtextcv + omega_textgrid l_f i_itextcv right) tag1a \n    doti_itextcv = fracOmega_bl_fleft( v_i^textcv - v_i  - r_f i_itextcv - omega_textgrid l_f i_rtextcv right) tag1b \n    dotv_r =  fracOmega_bc_fleft( i_r^textcv - i_r + omega_textgrid c_f v_i right) tag1c \n    dotv_i =  fracOmega_bc_fleft( i_i^textcv - i_i - omega_textgrid c_f v_r right) tag1d \n    doti_r = fracOmega_bl_gleft( v_r - v_r^textgrid - r_g i_r + omega_textgrid l_g i_itextcv right) tag1e \n    doti_i = fracOmega_bl_gleft( v_i - v_i^textgrid - r_g i_i - omega_textgrid l_g i_rtextcv right) tag1f\nendalign","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"on which","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"beginalign*\nv_r^textcv + jv_i^textcv = (v_d^textcv + jv_q^textcv)e^jdeltatheta_olc\nendalign*","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"that comes from the converter model.","category":"page"},{"location":"component_models/turbine_gov/#Prime-Movers-and-Turbine-Governors-(TG)","page":"Turbine and Governor","title":"Prime Movers and Turbine Governors (TG)","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This section describes how mechanical power is modified to provide primary frequency control with synchronous generators. It is assumed that tau_textref = P_textref since they are decided at nominal frequency omega = 1.","category":"page"},{"location":"component_models/turbine_gov/#Fixed-TG-[TGFixed]","page":"Turbine and Governor","title":"Fixed TG [TGFixed]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This a simple model that set the mechanical torque to be equal to a proportion of the desired reference tau_m = eta P_textref. To set the mechanical torque to be equal to the desired power, the value of eta is set to 1.","category":"page"},{"location":"component_models/turbine_gov/#TG-Type-I-[TGTypeI]","page":"Turbine and Governor","title":"TG Type I [TGTypeI]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This turbine governor is described by a droop controller and a low-pass filter to model the governor and two lead-lag blocks to model the servo and reheat of the turbine governor.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g1 = frac1T_s(p_textin - x_g1) tag1a \ndotx_g2 = frac1T_c left left(1- fract_3T_cright)x_g1 - x_g2 right tag1b \ndotx_g3 = frac1T_5 leftleft(1 - fracT_4T_5right)left(x_g2 + fracT_3T_cx_g1right) - x_g3  right tag1c \ntau_m = x_g3 + fracT_4T_5left(x_g2 + fracT_3T_cx_g1right) tag1d\nendalign","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"with","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign*\np_textin = P_textref + frac1R(omega_s - 10)\nendalign*","category":"page"},{"location":"component_models/turbine_gov/#TG-Type-II-[TGTypeII]","page":"Turbine and Governor","title":"TG Type II [TGTypeII]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This turbine governor is a simplified model of the Type I.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g = frac1T_2leftfrac1Rleft(1 - fracT_1T_2right) (omega_s - omega) - x_gright tag2a \ntau_m = P_textref + frac1RfracT_1T_2(omega_s - omega) tag2b\nendalign","category":"page"},{"location":"component_models/turbine_gov/#TGOV1-[SteamTurbineGov1]","page":"Turbine and Governor","title":"TGOV1 [SteamTurbineGov1]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This represents a classical Steam-Turbine Governor, known as TGOV1.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g1 = frac1T_1 (textref_in - x_g1) tag3a \ndotx_g2 = frac1T_3 left(x_g1^textsat left(1 - fracT_2T_3right) - x_g2right) tag3b\nendalign","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"with","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ntextref_in = frac1R (P_ref - (omega - 10)) tag3c \nx_g1^textsat = left beginarraycl\n                        x_g1  text if  V_min le x_g1 le V_max\n                        V_max  text if  x_g1  V_max \n                        V_min  text if  x_g1  V_min\n                    endarray right tag3d \ntau_m = x_g2 + fracT_2T_3 x_g1 - D_T(omega - 10) tag3e\nendalign","category":"page"},{"location":"component_models/turbine_gov/#GAST-[GasTG]","page":"Turbine and Governor","title":"GAST [GasTG]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This turbine governor represents the Gas Turbine representation, known as GAST.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g1 = frac1T_1 (x_in - x_g1) tag4a \ndotx_g2 = frac1T_2 left(x_g1^textsat - x_g2right) tag4b \ndotx_g3 = frac1T_3 (x_g2 - x_g3) tag4c\nendalign","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"with","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\nx_in = minleftP_ref - frac1R(omega - 10) A_T + K_T (A_T - x_g3) right tag4d \nx_g1^textsat = left beginarraycl\n                        x_g1  text if  V_min le x_g1 le V_max\n                        V_max  text if  x_g1  V_max \n                        V_min  text if  x_g1  V_min\n                    endarray right tag4e \ntau_m = x_g2  - D_T(omega - 10) tag4f\nendalign","category":"page"},{"location":"small/#Small-Signal-Analysis","page":"Small Signal","title":"Small Signal Analysis","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"Here we discuss the method used to do a small signal analysis on the DAE system defined in PowerSimulationsDynamics.jl. The package defines algebraic variables for both real and imaginary voltages on all buses (except if they have a dynamic line connected, on which the voltage of those buses are treated as differential variables). In addition, each dynamic device can add differential variables (or states) that are concatenated to construct the system of differential algebraic equations.","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"Note: The validation of small signal results is still work in progress due to the differences in the way that different software packages perform the calculations.","category":"page"},{"location":"small/#Automatic-Differentiation","page":"Small Signal","title":"Automatic Differentiation","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"Once an equilibrium point is found, the complete jacobian of the non-linear system can be obtained using automatic differentiation in Julia. In particular, the package ForwardDiff.jl is used to obtain the jacobian of the non-linear algebraic system of equations. PowerSimulationsDynamics.jl handles the resulting jacobian and reports the reduced jacobian and the corresponding eigenvalues and eigenvectors.","category":"page"},{"location":"small/#Jacobian-Reduction","page":"Small Signal","title":"Jacobian Reduction","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"We define y as the vector of algebraic variables, x as the vector of differential variables (states) and p the parameters of the system, we can define g(yxp) as the vector of algebraic equations and f(yxp) as the vector of differential equations. With that, the non-linear differential algebraic system of equations can be written as:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nleftbeginarrayc\n 0 \n  dotx\n  endarrayright = leftbeginarrayc\n  g(yxp) \n   f(yxp) endarrayright\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"For small signal analysis, we are interested in the stability around an equilbrium point y_eqx_eq that satisfies dotx = 0 or equivalently f(y_eqx_eqp) = 0, while obviously satisfying g(y_eq x_eq p) = 0. To do that we use a first order approximation:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nleftbeginarrayc\n 0 \n  Deltadotx\n  endarrayright = underbraceleftbeginarray\n  g(y_eqx_eqp) \n   f(y_eqx_eqp) endarrayright_ = 0\n + Jy_eq x_eq p leftbeginarrayc\n Delta y \n  Delta x\n  endarrayright\n  endalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"The first to note is that the jacobian matrix can be splitted in 4 blocks depending on the specific variables we are taking the partial derivatives:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nJy_eq x_eq p =\nleftbeginarraycc\n g_y  g_x \n f_y  f_x \n  endarrayright\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"For small signal analyses, we are interested in the stability of the differential states, while still considering that those need to evolve in the manifold defined by the linearized algebraic equations. Assuming that g_y is not singular (see chapter 7 of Federico Milano's book: Power System Modelling and Scripting or the following paper) we can eliminate the algebraic variables to obtain the reduced jacobian:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nJ_textred = f_x - f_y g_y^-1 g_x\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"that defines our reduced system for the differential variables","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nDelta dotx = J_textred Delta x\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"on which we can compute its eigenvalues to analyze local stability.","category":"page"},{"location":"component_models/freq_esti/#Frequency-Estimators","page":"Frequency Estimators","title":"Frequency Estimators","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"This component is used to estimate the frequency of the grid based on the voltage at the bus.","category":"page"},{"location":"component_models/freq_esti/#Fixed-Frequency-[FixedFrequency]","page":"Frequency Estimators","title":"Fixed Frequency [FixedFrequency]","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"This is a simple model that set the measured frequency to a desired constant value (i.e. does not measure the frequency) omega_pll = omega_textfix (usually omega_textfix = 10 p.u.). Used by default when grid-forming  inverters do not use frequency estimators. ","category":"page"},{"location":"component_models/freq_esti/#Phase-Locked-Loop-(PLL)-for-VSM-[KauraPLL]","page":"Frequency Estimators","title":"Phase-Locked Loop (PLL) for VSM [KauraPLL]","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"The following equations present a PLL used to estimate the frequency and PLL angle of the grid. There are two reference frames considered in this inverter. Those are the VSM of the outer-loop control deltatheta_textolc and the PLL one deltatheta_textpll. The notation used a deltatheta to refer as the variation of the respective angle theta with respect to the grid SRF (instead of the fixed alpha component of the alphabeta transformation):","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"beginalign\n\ndotv_dtextpll = omega_textlp left v_dtextout - v_dtextpll right tag1a \ndotv_qtextpll = omega_textlp left v_qtextout - v_qtextpll right tag1b \ndotvarepsilon_textpll = tan^-1left(fracv_qtextpllv_dtextpll right) tag1c \ndottheta_textpll = Omega_b delta omega_textpll tag1d\nendalign","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"with","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"beginalign\ndeltaomega_textpll = k_ptextpll tan^-1 left(fracv_qtextpllv_dtextpll right) + k_itextpll varepsilon_textpll tag1e \nv_dtextout + jv_qtextout = (v_r + jv_i)e^-deltatheta_textpll  tag1f\nendalign","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"on which v_r + jv_i is the voltage in the grid reference frame on which the PLL is measuring (i.e. point of common coupling), that could be in the capacitor of an LCL filter or the last branch of such filter.","category":"page"},{"location":"code_base_developer_guide/developer/#Guidelines-for-Developers","page":"Developer Guide","title":"Guidelines for Developers","text":"","category":"section"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to contribute to PowerSimulationsDynamics.jl repository please read the following sections of InfrastructureSystems.jl documentation in detail:","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"Style Guide\nContributing Guidelines","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"Pull requests are always welcome to fix bugs or add additional modeling capabilities.","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"All the code contributions need to include tests with a minimum coverage of 70%","category":"page"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/#Simulation-Models","page":"Models","title":"Simulation Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"PowerSimulations dynamics supports two formulations for the simulation model and define different methods for each simulation model. You can pass ImplicitModel or MassMatrixModel to a call to Simulation to define the preferred formulation.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"In this way, we provide a common set of development requirements for contributors of new models that maintains the same flexibility in choosing the solving algorithm.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"MassMatrixModel: Defines models that can be solved using Mass-Matrix Solvers. The model is formulated as follows:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign\nMfracdx(t)dt = x(t)\nendalign","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"At this stage we have not conducted extensive tests with all the solvers in DifferentialEquations most of our tests use Rodas5().","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"ImplicitModel: Define models that can be solved using Implicit ODE solvers and also the solver IDA from Sundials. The model is formulated to solved the following problem:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign\nr(t) = fracdx(t)dt - x(t)\nendalign","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"At this stage we have not conducted extensive tests with all the solvers in DifferentialEquations if you are solving a larger system use IDA().","category":"page"},{"location":"models/#The-dynamic-systen-model-in-PowerSimulationsDynamics","page":"Models","title":"The dynamic systen model in PowerSimulationsDynamics","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"In order to support both formulations, the default implementation of the ImplicitModel solves the following problem:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign\nr(t) = Mfracdx(t)dt - x(t)\nendalign","category":"page"},{"location":"models/#Generator-Models","page":"Models","title":"Generator Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Here we discuss the structure and models used to model generators in PowerSimulationsDynamics.jl. See PowerSystems.jl dynamic devices for details.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Each generator is a data structure composed of the following components defined in PowerSystems.jl:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Machine: That defines the stator electro-magnetic dynamics.\nShaft: That describes the rotor electro-mechanical dynamics.\nAutomatic Voltage Regulator: Electromotive dynamics to model an AVR controller.\nPower System Stabilizer: Control dynamics to define an stabilization signal for the AVR.\nPrime Mover and Turbine Governor: Thermo-mechanical dynamics and associated controllers.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The implementation of Synchronous generators as components uses the following structure to share values across components.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://github.com/NREL-SIIP/PowerSystems.jl/blob/master/docs/src/assets/gen_metamodel.png?raw=true\" width=\"75%\">","category":"page"},{"location":"models/#Inverter-Models","page":"Models","title":"Inverter Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Here we discuss the structure and models used to model inverters in PowerSimulationsDynamics.jl. See PowerSystems.jl dynamic devices for details. One of the key contributions in this software package is a separation of the components in a way that resembles current practices for synchronoues machine modeling.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"DC Source: Defines the dynamics of the DC side of the converter.\nFrequency Estimator: That describes how the frequency of the grid can be estimated using the grid voltages. Typically a phase-locked loop (PLL).\nOuter Loop Control: That describes the active and reactive power control dynamics.\nInner Loop Control: That can describe virtual impedance, voltage control and current control dynamics.\nConverter: That describes the dynamics of the pulse width modulation (PWM) or space vector modulation (SVM).\nFilter: Used to connect the converter output to the grid.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The following figure summarizes the components of a inverter and which variables they share:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://github.com/NREL-SIIP/PowerSystems.jl/blob/master/docs/src/assets/inv_metamodel.png?raw=true\" width=\"75%\">","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Contrary to the generator, there are many control structures that can be used to model inverter controllers (e.g. grid-following, grid feeding or virtual synchronous machine). For this purpose, more variables are shared among the components in order to cover all these posibilities.","category":"page"},{"location":"models/#Reference","page":"Models","title":"Reference","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"For models, check the library in PowerSystems.jl","category":"page"},{"location":"component_models/avr/#Automatic-Voltage-Regulators-(AVR)","page":"AVR","title":"Automatic Voltage Regulators (AVR)","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"AVR are used to determine the voltage in the field winding v_f (or V_f) in the model.","category":"page"},{"location":"component_models/avr/#Fixed-AVR-[AVRFixed]","page":"AVR","title":"Fixed AVR [AVRFixed]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This is a simple model that set the field voltage to be equal to a desired constant value v_f = v_textfix.","category":"page"},{"location":"component_models/avr/#Simple-AVR-[AVRSimple]","page":"AVR","title":"Simple AVR [AVRSimple]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This depicts the most basic AVR, on which the field voltage is an integrator over the difference of the measured voltage and a reference:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotv_f = K_v(v_textref - v_h) tag1a\nendalign","category":"page"},{"location":"component_models/avr/#AVR-Type-I-[AVRTypeI]","page":"AVR","title":"AVR Type I [AVRTypeI]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This AVR is a simplified version of the IEEE DC1 AVR model:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotv_f = -frac1T_e left V_f(K_e + S_e(v_f))-v_r1 right tag2a \ndotv_r1 = frac1T_a left K_aleft(v_textref - v_m - v_r2 - fracK_fT_fv_fright) - v_r1 right   tag2b \ndotv_r2 =  -frac1T_f left fracK_fT_fv_f + v_r2 right  tag2c \ndotv_m = frac1T_r (v_h - v_m) tag2d\nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with the ceiling function:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"component_models/avr/#AVR-Type-II-[AVRTypeII]","page":"AVR","title":"AVR Type II [AVRTypeII]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This model represents a static exciter with higher gains and faster response than the Type I:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotv_f = -frac1T_e left V_f(1 + S_e(v_f))-v_r right tag3a \ndotv_r1 = frac1T_1 left K_0left(1 - fracT_2T_1 right)(v_textref - v_m) - v_r1  right tag3b \ndotv_r2 =  frac1K_0 T_3 left left( 1 - fracT_4T_3 right) left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) - K_0 v_r2 right  tag3c \ndotv_m = frac1T_r (v_h - v_m) tag3d\nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nv_r = K_0v_r2 + fracT_4T_3 left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) \nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"component_models/avr/#Excitation-System-AC1A-[ESAC1A]","page":"AVR","title":"Excitation System AC1A [ESAC1A]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"The model represents the 5-states IEEE Type AC1A Excitation System Model:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotV_m = frac1T_r (V_h - V_m) tag4a \ndotV_r1 = frac1T_b left(V_in left(1 - fracT_cT_bright) - V_r1right) tag4b \ndotV_r2 = frac1T_a (K_a V_out - V_r2) tag4c \ndotV_e = frac1T_e (V_r - V_FE) tag4d \ndotV_r3 = frac1T_f left( - fracK_fT_fV_FE - V_r3 right) tag4e \nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nI_N = fracK_cV_e X_adI_fd \nV_FE = K_d X_adI_fd + K_e V_e + S_e V_e \nS_e = Bfrac(V_e-A)^2V_e \nV_F1 = V_r3 + fracK_fT_f V_FE \nV_in = V_ref - V_m - V_F1 \nV_out = V_r1 + fracT_cT_b V_in \nV_f = V_e f(I_N) \nf(I_N) = leftbeginarraycl\n    1  text if I_N le 0 \n    1 - 0577 I_N  text if  0  I_N le 0433 \n    sqrt075 - I_N^2  text if  0433  I_N le 075 \n    1732(1-I_N)  text if  075   I_N le 1 \n    0  text if  I_N  1 endarray right\nendalign*","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"on which X_adI_fd is the field current coming from the generator and V_h is the terminal voltage, and AB are the saturation coefficients computed using the E_1 E_2 S_e(E_1) S_e(E_2) data.","category":"page"},{"location":"component_models/outer_control/#Outer-Loop-Controls","page":"Outer Control","title":"Outer Loop Controls","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"This component defines controllers for both active and reactive power. The joint design is based on the fact that many novel control techniques can be based on joint control of active and reactive power.","category":"page"},{"location":"component_models/outer_control/#Virtual-Inertia-and-Q-droop-[OuterControl]","page":"Outer Control","title":"Virtual Inertia and Q-droop [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represent a virtual synchronous machine model to represent how active power is going to be deployed. The constructor is OuterControl{VirtualInertia, ReactivePowerDroop}. It defines a new SRF denoted as theta_textolc for the active power controller and uses a simple voltage droop for dispatching reactive power:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotdeltaomega_textolc = fracp_textrefT_a - fracp_eT_a - frack_d(omega_textolc - omega_textpll)T_a - frack_omega(omega_textolc - omega_textref)T_a tag1a \n    dottheta_textolc = Omega_b deltaomega_textolc tag1b \n    dotq_m = omega_f (q_e - q_m) tag1c\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    p_e = v_ri_r + v_ii_i tag1d \n    q_e = v_ii_r - v_ri_i tag1e \n    v_textolc^textref = v_textref + k_q(q_textref - q_m) tag1f\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In this case, the measurement of power are being done in the capacitor of the LCL filter. However, depending on the model, this measurements could be different depending on where is the point of common coupling.","category":"page"},{"location":"component_models/outer_control/#Active-Power-Droop-(P-droop)-and-Q-droop-[OuterControl]","page":"Outer Control","title":"Active Power Droop (P-droop) and Q-droop [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represent a Ptext-f droop model to represent how active power is going to be deployed. The constructor is OuterControl{ActivePowerControl, ReactivePowerDroop}. It defines a new SRF denoted as theta_textolc for the active power controller and uses a simple voltage droop for dispatching reactive power. Both active and reactive power are measured via a low-pass filter:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dottheta_textolc = Omega_b (omega_textolc - omega_textsys) tag2a \n    dotp_m = omega_z (p_e - p_m) tag2b \n    dotq_m = omega_f (q_e - q_m) tag2c\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    p_e = v_ri_r + v_ii_i tag2d \n    q_e = v_ii_r - v_ri_i tag2e \n    omega_textolc = omega_textref + R_p (p_textref - p_e) tag2f \n    v_textolc^textref = v_textref + k_q(q_textref - q_m) tag2g\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In this case, the measurement of power are being done in the capacitor of the LCL filter. However, depending on the model, this measurements could be different depending on where is the point of common coupling.","category":"page"},{"location":"component_models/outer_control/#Active-and-Reactive-Power-PI-Controllers-(Grid-Following)-[OuterControl]","page":"Outer Control","title":"Active and Reactive Power PI Controllers (Grid Following) [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represents a PI controller for both active and reactive power to generate the current references that will be used in the Current Controller of the inner control CurrentModeControl. The constructor is OuterControl{ActivePowerPI, ReactivePowerPI}. The equations are:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotsigma_p = p_textref - p_m tag3a \n    dotp_m = omega_z (p_e - p_m) tag3b \n    dotsigma_q = q_textref - q_m tag3c \n    dotq_m = omega_f (q_e - p_m) tag3d \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    p_e = v_ri_r + v_ii_i tag3e \n    q_e = v_ii_r - v_ri_i tag3f \n    omega_textolc = omega_textpll tag3g \n    theta_textolc = theta_textpll tag3h \n    i_textdcv^textref = k_p^q (q_textref - q_m) + k_i^q sigma_q tag3i \n    i_textqcv^textref = k_p^p (p_textref - p_m) + k_i^p sigma_p tag3j \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"This models requires a PLL to have a SRF for an internal dq reference frame. Contrary to the Grid-Forming model, it cannot work without a PLL. Since this Outer Control outputs a current reference, it can only be used with a current mode inner control (i.e. that receives  a current reference instead of a voltage reference).","category":"page"},{"location":"component_models/machines/#Machines","page":"Machine","title":"Machines","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The machine component describes the stator-rotor electromagnetic dynamics.","category":"page"},{"location":"component_models/machines/#Classical-Model-(Zero-Order)-[BaseMachine]","page":"Machine","title":"Classical Model (Zero Order) [BaseMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This is the classical order model that does not have differential equations in its machine model (delta and omega are defined in the shaft):","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_d  x_d  r_a endarray right^-1  left beginarrayc -v_d  e_q - v_q endarray right tag1a\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag1b\nendalign","category":"page"},{"location":"component_models/machines/#One-d-One-q-Model-(2nd-Order)-[OneDOneQMachine]","page":"Machine","title":"One d- One q- Model (2nd Order) [OneDOneQMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model includes two transient emf with their respective differential equations:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 left-e_q + (x_d-x_d)i_d + v_fright tag2a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag2b\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag2c\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag2d\nendalign","category":"page"},{"location":"component_models/machines/#Marconato-Machine-(6th-Order)-[MarconatoMachine]","page":"Machine","title":"Marconato Machine (6th Order) [MarconatoMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The Marconato model defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag3a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag3b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag3c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag3d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag3e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag3f \ni_d = frac1x_d (e_q - psi_d) tag3g \ni_q = frac1x_q (-e_d - psi_q) tag3h \ntau_e = psi_d i_q - psi_q i_d tag3i\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"component_models/machines/#Simplified-Marconato-Machine-(4th-Order)-[SimpleMarconatoMachine]","page":"Machine","title":"Simplified Marconato Machine (4th Order) [SimpleMarconatoMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omegapsi_d=psi_d and omegapsi_q=psi_q) that allows to remove the stator fluxes variables from the Marconato model.","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag4a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag4b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag4c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag4d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag4e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag4f\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"component_models/machines/#Anderson-Fouad-Machine-(6th-Order)-[AndersonFouadMachine]","page":"Machine","title":"Anderson-Fouad Machine (6th Order) [AndersonFouadMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The Anderson-Fouad model also defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs and is derived from the Marconato model by defining gamma_d approx gamma_q approx T_AA approx 0:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag5a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag5b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag5c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag5d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag5e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag5f \ni_d = frac1x_d (e_q - psi_d) tag5g \ni_q = frac1x_q (-e_d - psi_q) tag5h \ntau_e = psi_d i_q - psi_q i_d tag5i\nendalign","category":"page"},{"location":"component_models/machines/#Simplified-Anderson-Fouad-Machine-(4th-Order)-[SimpleAFMachine]","page":"Machine","title":"Simplified Anderson-Fouad Machine (4th Order) [SimpleAFMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"Similar to the Simplified Marconato Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omega psi_d = psi_d and omega psi_q = psi_q) that allows to remove the stator fluxes variables from the model:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag6a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag6b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag6c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag6d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag6e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag6f\nendalign","category":"page"},{"location":"component_models/machines/#Round-Rotor-Machine-(4th-Order)-[RoundRotorQuadratic,-RoundRotorExponential]","page":"Machine","title":"Round Rotor Machine (4th Order) [RoundRotorQuadratic, RoundRotorExponential]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model represents the traditional round rotor models GENROU/GENROE models implemented in PSLF/PSSE/PowerWorld. Similar to the Simplified Marconato Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q). Round rotor machines must satisfy x_d = x_q.","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 leftv_f - X_adI_fdright tag7a\ndote_d = frac1T_q0 left-X_aqI_1q right tag7b\ndotpsi_kd = frac1T_d0 left-psi_kd + e_q - (x_d-x_l)i_d right tag7c \ndotpsi_kq = frac1T_q0 left-psi_kq + e_d + (x_q-x_l)i_q right tag7d \nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ngamma_d1 = fracx_d - x_lx_d - x_l tag7e\ngamma_q1 = fracx_q - x_lx_q - x_l tag7f\ngamma_d2 = fracx_d - x_d(x_d-x_l)^2 tag7g\ngamma_q2 = fracx_q - x_q(x_q - x_l)^2 tag7h\ngamma_qd = fracx_q - x_lx_d - x_l tag7i\npsi_q = gamma_q1 e_d + psi_kq (1 - gamma_q1) tag7j\npsi_d = gamma_d1 e_q + gamma_d2 (x_d - x_l) psi_kd tag7k\npsi = sqrt(psi_d)^2 + (psi_q)^2 tag7l\nleft beginarrayc i_d  i_q endarray right = left beginarraycc -r_a  x_q  -x_d  r_a endarray right^-1  left beginarrayc v_d - psi_q  -v_q + psi_d endarray right tag7m\nX_adI_fd = e_q + (x_d - x_d) (gamma_d1 i_d - gamma_d2 psi_kd + gamma_d2 + e_q) + textSe(psi) psi_d tag7n\nX_aqI_1q = e_d + (x_q - x_q) (gamma_q2 e_d - gamma_q2psi_kq - gamma_q1 i_q) + textSe(psi) psi_q gamma_qd tag7o \ntau_e = i_d (r_a i_d + v_d) + i_q(r_a i_q + v_q) tag7p\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The difference between GENROU and GENROE occurs in which additive saturation function textSe(psi) is used. Input data is provided by the saturation values at psi = 10 and psi = 12 p.u. For the GENROU model, the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(psi) = fracB(psi - A)^2 psi tag7q\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"and for the GENROE model the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(psi) = B(psi)^A tag7r\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The parameters A and B for each function are computed using the two points given (10 textSe(10)) and (12 textSe(12)).","category":"page"},{"location":"component_models/machines/#Salient-Pole-Machine-(3rd-Order)-[SalientPoleQuadratic,-SalientPoleExponential]","page":"Machine","title":"Salient Pole Machine (3rd Order) [SalientPoleQuadratic, SalientPoleExponential]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model represents the traditional round rotor models GENSAL/GENSAE models implemented in PSLF/PSSE/PowerWorld. Similar to the GENROU Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q).","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 leftv_f - X_adI_fdright tag8a\ndotpsi_kd = frac1T_d0 left-psi_kd + e_q - (x_d-x_l)i_d right tag8b \ndotpsi_q = frac1T_q0 left-psi_q - (x_q-x_q)i_q right tag8c \nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ngamma_d1 = fracx_d - x_lx_d - x_l tag8d\ngamma_q1 = fracx_q - x_lx_q - x_l tag8e\ngamma_d2 = fracx_d - x_d(x_d-x_l)^2 tag8f\npsi_d = gamma_d1 e_q + gamma_q1 psi_kd tag8g\nleft beginarrayc i_d  i_q endarray right = left beginarraycc -r_a  x_q  -x_d  r_a endarray right^-1  left beginarrayc v_d - psi_q  -v_q + psi_d endarray right tag8h\nX_adI_fd = e_q + textSe(e_q) e_q + (x_d - x_d) (i_d + gamma_d2 (e_q - psi_kd - (x_d - x_l)i_d) tag8i\ntau_e = i_d (r_a i_d + v_d) + i_q(r_a i_q + v_q) tag8j\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The difference between GENSAL and GENSAE occurs in which additive saturation function textSe(e_q) is used. Input data is provided by the saturation values at e_q = 10 and e_q = 12 p.u. For the GENSAL model, the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(e_q) = fracB(e_q - A)^2 e_q tag8k\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"and for the GENSAE model the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(e_q) = B(e_q)^A tag8l\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The parameters A and B for each function are computed using the two points given (10 textSe(10)) and (12 textSe(12)).","category":"page"},{"location":"component_models/shafts/#Shafts","page":"Shaft","title":"Shafts","text":"","category":"section"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"The shaft component defines the rotating mass of the synchronous generator.","category":"page"},{"location":"component_models/shafts/#Rotor-Mass-Shaft-[SingleMass]","page":"Shaft","title":"Rotor Mass Shaft [SingleMass]","text":"","category":"section"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"This is the standard model, on which one single mass (typically the rotor) is used to model the entire inertia of the synchronous generator. Each generator's rotating frame use a reference frequency omega_s, that typically is the synchronous one (i.e. omega_s = 10). The model defines two differential equations for the rotor angle delta and the rotor speed omega:","category":"page"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag1a \ndotomega = frac12H(tau_m - tau_e - D(omega-omega_s)) tag1b\nendalign","category":"page"},{"location":"component_models/shafts/#Five-Mass-Shaft-[FiveMassShaft]","page":"Shaft","title":"Five-Mass Shaft [FiveMassShaft]","text":"","category":"section"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"This model describes model connecting a high-pressure (hp) steam turbine, intermediate-pressure (ip) steam turbine, low-pressure (lp) steam pressure, rotor and exciter (ex) connected in series (in that order) in the same shaft using a spring-mass model:","category":"page"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag2a \ndotomega = frac12H left- tau_e - D(omega-omega_s)) - D_34 (omega-omega_lp) - D_45(omega-omega_ex) + K_lp(delta_lp-delta) +K_ex(delta_ex-delta) right tag2b \ndotdelta_hp = Omega_b(omega_hp - omega_s) tag2c \ndotomega_hp = frac12H_hp left tau_m - D_hp(omega_hp-omega_s) - D_12(omega_hp - omega_ip) + K_hp(delta_ip - delta_hp) right tag2d \ndotdelta_ip = Omega_b(omega_ip - omega_s) tag2e \ndotomega_ip = frac12H_ip left- D_ip(omega_ip-omega_s) - D_12(omega_ip - omega_hp) -D_23(omega_ip - omega_lp ) + K_hp(delta_hp - delta_ip) + K_ip(delta_lp-delta_ip) right tag2f \ndotdelta_lp = Omega_b(omega_lp-omega_s) tag2g \ndotomega_lp = frac12H_lp left - D_lp(omega_lp-omega_s) - D_23(omega_lp - omega_ip) -D_34(omega_lp - omega ) + K_ip(delta_ip - delta_lp) + K_lp(delta-delta_lp) right tag2h \ndotdelta_ex = Omega_b(omega_ex-omega_s) tag2i \ndotomega_ex = frac12H_ex left - D_ex(omega_ex-omega_s) - D_45(omega_ex - omega) + K_ex(delta - delta_ex) right tag2j\nendalign","category":"page"},{"location":"api/public/#PowerSimulationsDynamics","page":"Public API Reference","title":"PowerSimulationsDynamics","text":"","category":"section"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"CurrentModule = PowerSimulationsDynamics\nDocTestSetup  = quote\n    using PowerSimulationsDynamics\nend","category":"page"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [PowerSimulationsDynamics]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/public/#PowerSimulationsDynamics.BranchTrip","page":"Public API Reference","title":"PowerSimulationsDynamics.BranchTrip","text":"Use to model the trip of an AC Branch in in the system. Accepts lines or transformer lines\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.ControlReferenceChange","page":"Public API Reference","title":"PowerSimulationsDynamics.ControlReferenceChange","text":"Use to model control reference changes in devices of the model\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.NetworkSwitch","page":"Public API Reference","title":"PowerSimulationsDynamics.NetworkSwitch","text":"Use to model a change in the network by switching the underlying Ybus in the simulation\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.Simulation-Union{Tuple{T}, Tuple{Type{T}, System, String, Tuple{Float64, Float64}}, Tuple{Type{T}, System, String, Tuple{Float64, Float64}, Vector{var\"#s12\"} where var\"#s12\"<:PowerSimulationsDynamics.Perturbation}} where T<:PowerSimulationsDynamics.SimulationModel","page":"Public API Reference","title":"PowerSimulationsDynamics.Simulation","text":"Initializes the simulations and builds the indexing. The input system is not modified during the initialization\n\nAccepted Key Words\n\ninitialize_simulation::Bool : Runs the initialization routine. If false, simulation runs based on the operation point stored in System\nsystem_to_file::Bool: Serializes the original input system\nconsole_level::Logging: Sets the level of logging output to the console. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debugg\nfile_level::Logging: Sets the level of logging output to file. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.Simulation!-Union{Tuple{T}, Tuple{Type{T}, System, String, Tuple{Float64, Float64}}, Tuple{Type{T}, System, String, Tuple{Float64, Float64}, Vector{var\"#s12\"} where var\"#s12\"<:PowerSimulationsDynamics.Perturbation}} where T<:PowerSimulationsDynamics.SimulationModel","page":"Public API Reference","title":"PowerSimulationsDynamics.Simulation!","text":"Builds the simulation object and conducts the indexing process. The initial conditions are stored in the system.\n\nAccepted Key Words\n\ninitialize_simulation::Bool : Runs the initialization routine. If false, simulation runs based on the operation point stored in System\nsystem_to_file::Bool: Serializes the initialized system\nconsole_level::Logging: Sets the level of logging output to the console. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\nfile_level::Logging: Sets the level of logging output to file. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_activepower_series-Tuple{Simulation, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_activepower_series","text":"Function to obtain the active power output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_initial_conditions-Tuple{Simulation}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_initial_conditions","text":"Returns a Dictionary with the resulting initial conditions of the simulation\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_reactivepower_series-Tuple{Simulation, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_reactivepower_series","text":"Function to obtain the reactive power output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_state_series-Tuple{Simulation, Tuple{String, Symbol}}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_state_series","text":"Function to obtain series of states out of DAE Solution. It receives the solution, the dynamical system and a tuple containing the string name of the Dynamic Injection device and the symbol of the state.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_voltage_angle_series-Tuple{Simulation, Int64}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_voltage_angle_series","text":"Function to obtain the voltage angle series out of the DAE Solution. It receives the solution, the dynamical system and the bus number.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_voltage_magnitude_series-Tuple{Simulation, Int64}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_voltage_magnitude_series","text":"Function to obtain the voltage magnitude series out of the DAE Solution. It receives the solution, the dynamical system and the bus number.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.print_device_states-Tuple{Simulation}","page":"Public API Reference","title":"PowerSimulationsDynamics.print_device_states","text":"Function to print initial states. It receives the vector of initial states and the dynamical system.\n\n\n\n\n\n","category":"method"},{"location":"component_models/network/#Network-model","page":"Network","title":"Network model","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Here we discuss the models used to describe the network in PowerSimulationsDynamics.jl. This is based on a standard current injection model as defined in Power System Modelling and Scripting. The numerical advantages of current injection models outweigh the complexities of implementing constant power loads for longer-term transient stability analysis. The network is defined in a synchronous reference frame (SRF), named the RI (real-imaginary) reference frame, rotating at the constant base frequency Omega_b.","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"In simple terms, PowerSimulationsDynamics.jl internally tracks the current-injection balances at the nodal level from all the devices on the system. Based on the buses and branches information, the system constructor computes the admittance matrix boldsymbolY assuming nominal frequency and this is used for static branch modeling. The algebraic equations for the static portions of the network are as follows:","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":" beginalign\n 0 = boldsymboli(boldsymbolx boldsymbolv) - boldsymbolYboldsymbolv\n endalign","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"where boldsymboli = i_r + ji_i is the vector of the sum of complex current injections from devices , boldsymbolx is the vector of states and boldsymbolv = v_r + jv_i is the vector of complex bus voltages. Equations (1) connect all the port variables, i.e., currents, defined for each injection device. Components that contribute to (1) by modifying the current boldsymboli are (i) static injection devices, (ii) dynamic injection devices, and (iii) dynamic network branches. Components that contribute to modify the admittance matrix boldsymbolY are static branches.","category":"page"},{"location":"component_models/network/#Static-Branches-(or-Algebraic-Branches)","page":"Network","title":"Static Branches (or Algebraic Branches)","text":"","category":"section"},{"location":"component_models/network/#Lines","page":"Network","title":"Lines","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Each line is defined using a pi model connecting two buses (nm), with a series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m). The values are already in system per unit. Then each branch contributes to the admittance matrix as follows:","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"beginalign\nY_nn += frac1r+jx + jc_n \nY_nm += frac-1r+jx \nY_mm += frac1r+jx + jc_m \nY_mn += frac-1r+jx \nendalign","category":"page"},{"location":"component_models/network/#Two-Windings-Transformers","page":"Network","title":"Two-Windings Transformers","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Similarly to lines these are defined by a series reactance and impedance. The equations are equivalently of the lines without the shunt capacitance.","category":"page"},{"location":"component_models/network/#Dynamic-Branches","page":"Network","title":"Dynamic Branches","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Dynamic network branches contribute directly to (1) by modifying the vector of complex currents. Their parameters are also the series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m) for a line ell. In addition, they define 3 new additional differential equations per line (6 in total for real and imaginary part):","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"beginalign\n    fraclOmega_b fracdboldsymboli_elldt = (boldsymbolv_n - boldsymbolv_m) - (r+jl) boldsymboli_ell \n     fracc_nOmega_b fracdboldsymbolv_ndt =  boldsymboli_n^textcap - jc_nboldsymbolv_n   \n      fracc_mOmega_b fracdboldsymbolv_mdt = boldsymboli_m^textcap - jc_mboldsymbolv_m\nendalign","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Since all the values are in per unit, the reactance is equal to the inductance.","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"A detail discussion about the effects of different line models in the modeling of inverters is presented in Grid Forming Inverter Small Signal Stability: Examining Role of Line and Voltage Dynamics","category":"page"},{"location":"component_models/pss/#Power-System-Stabilizers-(PSS)","page":"PSS","title":"Power System Stabilizers (PSS)","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"PSS are used to add an additional signal v_s to the field voltage: v_f = v_f^textavr + v_s.","category":"page"},{"location":"component_models/pss/#Fixed-PSS-[PSSFixed]","page":"PSS","title":"Fixed PSS [PSSFixed]","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"This is a simple model that set the stabilization signal to be equal to a desired constant value v_s = v_s^textfix. The absence of PSS can be modelled using this component with v_s^textfix = 0.","category":"page"},{"location":"component_models/pss/#Simple-PSS-[PSSSimple]","page":"PSS","title":"Simple PSS [PSSSimple]","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"This is the most basic PSS that can be implemented, on which the stabilization signal is  a proportional controller over the frequency and electrical power:","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"beginalign\nv_s = K_omega(omega - omega_s) + K_p(omega tau_e - P_textref) tag1a\nendalign","category":"page"},{"location":"initialization/#Initialization-Routine","page":"Initialization","title":"Initialization Routine","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Dynamic Simulations require a reasonable initial condition for the model. In most analysis, power systems models are initialized at a stable equilibrium, which implies that:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"beginalign\n0 = F(x u eta)\nendalign","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Finding the solution of a large non-linear system is challenging and requires a reasonable initial guess. In classical power systems literature, the routine to find equilibrium points for the dynamic injection devices' components is well known and used in free and commercial software (see Power System Modelling and Scripting page 224). However, in the case of converter interface dynamic injection models, such routines are not documented.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This page shows the initialization details in PowerSimulationsDynamics.jl","category":"page"},{"location":"initialization/#System-wide-routine","page":"Initialization","title":"System-wide routine","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The initialization routine starts from the solution of the power flow equations. For each dynamic injection device PowerSimulationsDynamics.jl finds the solution of the systems of non-linear equations for each dynamic component following the sequences described in the forthcoming sections.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Once each device is individually initialized, the system-wide initial guess is used to solve the system (1). In a first attempt at finding the solution, the tolerance is set to a stringent tolerance. If the non-linear solver is unable to get a solution, it might usually reflect small signal stability problems in the system. In a second attempt, the tolerances are relaxed. If the solver succeeds, the simulation continues, but the user is warned.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"<img src=\"../assets/sys_init.png\" width=\"65%\">","category":"page"},{"location":"initialization/#Initialization-of-the-Synchronous-Machines","page":"Initialization","title":"Initialization of the Synchronous Machines","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The initialization of Synchronous Machines is standard in power systems and follows the scheme shown in the figure. Other internal variables are calculated recursively from the power flow solution for the node on which the dynamic device isconnected. (Adapted from Power System Modelling and Scripting Figure 9.2)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"(Image: init_machine)","category":"page"},{"location":"initialization/#Initialization-of-the-Inverters","page":"Initialization","title":"Initialization of the Inverters","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Initializing the inverters follows the sequence shown in the figure and has been developed to be compatible with the implementation of custom dynamic components. Given that the process is less studied and standard than the one of the synchronous machine, this page contains more detailed documentation of the process.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"(Image: init_machine)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The first component to be initialized is the filter. Given that the filter is an RLC circuit connected to the grid, its currents and voltages need to match the results of the power flow. The initialization of the filter provides the values for the P and Q used in the outer control and the V and I needed in the inner controls.\nBased on the bus voltage in the system's reference frame V_r and the bus angle theta the PLL's can be initialized to obtain the angle and frequency estimates needed by the outer control.\nThe Outer Control calculates the internal angle delta_olc required by the inner control to estimate the voltage and current phase difference.\nThe DC Source uses the power set-point consistent with the power outputs of the filter to initialize the V_dc set-points. This value is used in the inner control.\nThe inner control takes the phase angle delta_olc and the V_dc to estimate the modulation values of the PWM converter.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Note: The initialization of an inverter through the proposed meta-model is actively under development and subject to change. This page will maintain the latest version of the sequence.","category":"page"},{"location":"tutorials_page/#SIIP-Examples","page":"Tutorials","title":"SIIP-Examples","text":"","category":"section"},{"location":"tutorials_page/","page":"Tutorials","title":"Tutorials","text":"All the tutorials for the SIIP project are part of a separate repository SIIP-Examples. You can access the latest PowerSimulationsDynamics.jl tutorial notebooks in this link","category":"page"},{"location":"tutorials_page/","page":"Tutorials","title":"Tutorials","text":"Specific examples of common workflows and models:","category":"page"},{"location":"tutorials_page/","page":"Tutorials","title":"Tutorials","text":"Loading Dynamic Data\nSolving a One Machine against Infinite Bus model\nChanging line modeling assumptions\nUsing an Inverter in a Multi-Machine Model","category":"page"},{"location":"reference_frames/#Reference-Frames","page":"Reference Frames","title":"Reference Frames","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"Each dynamic device is defined in its own dq synchronous reference frame (SRF). It is important to note that there are several conventions to do reference frame transformations.","category":"page"},{"location":"reference_frames/#Synchronous-Machines","page":"Reference Frames","title":"Synchronous Machines","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"The grid is modeled in its own real-imaginary (RI) reference frame. With such, this follows the standard convention that for a voltage angle theta = 0, there is no imaginary part and hence v_h = v_r + j0. Traditionally, the reference frame dq with rotor angle delta for synchronous machines connected to a bus v_hangle theta = v_r + jv_i follows the following convention for transformation of per-unit RMS phasors:","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"beginalign\nv_d + jv_q = (v_r + jv_i) e^-j(delta- pi2) tag1a \nv_d =  v_h sin(delta - theta) tag1b \nv_q = v_h cos(delta - theta) tag1c \nleft beginarrayc v_d  v_q endarray right = left beginarraycc sin(delta)  -cos(delta)  cos(delta)  sin(delta) endarray right left beginarrayc v_r  v_i endarray right tag1d\nendalign","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"Note that hence in a bus of 10angle 0, a rotor angle of delta = 0 implies that v_q = 10 and v_d = 00. This transformation is the one that can be found in most books of Power Systems, such as Kundur, Sauer Pai and in Milano too, and is the convention used in the software to model dynamic models of synchronous machines in their own reference frame.","category":"page"},{"location":"reference_frames/#Inverters","page":"Reference Frames","title":"Inverters","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"The previously convention is not the standard one used for modeling inverters. Most of inverter and phase-lock loop (PLL) models follow the next convention:","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"beginalign\nv_d + jv_q = (v_r + jv_i) e^-j delta tag2a  \nv_d =  v_h cos(delta - theta) tag2b \nv_q = -v_h sin(delta - theta) tag2c\nendalign","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"That, contrary to the previous case, when delta = theta = 0 implies that v_d = 10 and v_q = 00. This yields the typical PLL conditions that steer v_q to 0 when delta locks in theta, or when both SRF lock between each other.","category":"page"},{"location":"reference_frames/#Transformation-used","page":"Reference Frames","title":"Transformation used","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"Given the predominancy of both convention in current work, the software uses both conventions depending on the device modeled. For synchronous machines we used the standard convention (1a)-(1d), while for inverter models we use the predominant convention used nowadays in such models, i.e. (2a)-(2c).","category":"page"},{"location":"component_models/dc_source/#DC-Source","page":"DC Sources","title":"DC Source","text":"","category":"section"},{"location":"component_models/dc_source/","page":"DC Sources","title":"DC Sources","text":"This component can be used to model the dynamics of the DC side of the converter.","category":"page"},{"location":"component_models/dc_source/#Fixed-DC-Source-[FixedDCSource]","page":"DC Sources","title":"Fixed DC Source [FixedDCSource]","text":"","category":"section"},{"location":"component_models/dc_source/","page":"DC Sources","title":"DC Sources","text":"This is a model that set the DC voltage to a fixed value v_textdc = v_textdc^textfix.","category":"page"},{"location":"api/internal/#Internal","page":"Internal API Reference","title":"Internal","text":"","category":"section"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"CurrentModule = PowerSimulationsDynamics\nDocTestSetup  = quote\n    using PowerSimulationsDynamics\nend","category":"page"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [PowerSimulationsDynamics]\nPublic = false\nPrivate = true","category":"page"},{"location":"api/internal/#PowerSimulationsDynamics.BUILD_STATUS","page":"Internal API Reference","title":"PowerSimulationsDynamics.BUILD_STATUS","text":"Defines the status of the simulation object\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.generator_inner_vars","page":"Internal API Reference","title":"PowerSimulationsDynamics.generator_inner_vars","text":"Generator Inner Vars:\n\nÏe_var :: Electric torque\nÏm_var :: Mechanical torque\nVf_var :: Field voltage\nV_pss_var :: Additional PSS voltage\nVR_gen_var :: Real part of the terminal voltage\nVI_gen_var :: Imaginary part of the terminal voltage\nÏd_var :: Stator Flux (if defined) in the d-axis\nÏq_var :: Stator Flux (if defined) in the q-axis\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.inverter_inner_vars","page":"Internal API Reference","title":"PowerSimulationsDynamics.inverter_inner_vars","text":"Inverter Inner Vars:\n\nmd_var :: Modulation signal on the d-component\nmq_var :: Modulation signal on the q-component\nVdc_var :: DC voltage supplied by the DC source\nVr_filter_var :: Voltage seen in the capacitor of the filter in the R-component\nVi_filter_var :: Voltage seen in the capacitor of the filter in the I-component\nÎ¸_freq_estimator_var :: Angle estimated by the frequency estimator.\nÏ_freq_estimator_var :: Frequency estimated by the frequency estimator.\nV_oc_var :: Control voltage reference in the d-axis supplied from the outer loop control to the inner loop (for Voltage Mode Control)\nId_oc_var :: Control current reference in the d-axis supplied from the outer loop control to the inner loop (for Current Mode Control)\nIq_oc_var :: Control current reference in the q-axis supplied from the outer loop control to the inner loop (for Current Mode Control)\nÏ_oc_var :: Control frequency supplied from the outer loop control the inner loop\nÎ¸_oc_var :: Variation of the angle (PLL or VSM) of the inverter\nVR_inv_var :: Real terminal voltage on the inverter\nVI_inv_var :: Imaginary terminal voltage on the inverter\nVr_cnv_var :: Voltage supplied from the converter in the R-component\nVi_cnv_var :: Voltage supplied from the converter in the I-component\nP_ES_var :: Power supplied from the Energy Source side\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics._filter_current-Tuple{LCLFilter, String, Vector{Float64}, Vector{Float64}, Float64, Simulation}","page":"Internal API Reference","title":"PowerSimulationsDynamics._filter_current","text":"Function to obtain the output current time series of a LCL Filter model out of the DAE Solution. It is dispatched via the Filter type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{BaseMachine, String, Vector{Float64}, Vector{Float64}, Float64, Simulation}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a Classic Machine model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{OneDOneQMachine, String, Vector{Float64}, Vector{Float64}, Float64, Simulation}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a One-D-One-Q model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{Union{AndersonFouadMachine, MarconatoMachine}, String, Vector{Float64}, Vector{Float64}, Float64, Simulation}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a Marconato or AndersonFouad model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{Union{RoundRotorExponential, RoundRotorQuadratic}, String, Vector{Float64}, Vector{Float64}, Float64, Simulation}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a GENROU/GENROE model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{Union{SalientPoleExponential, SalientPoleQuadratic}, String, Vector{Float64}, Vector{Float64}, Float64, Simulation}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a GENSAL/GENSAE model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{Union{SimpleAFMachine, SimpleMarconatoMachine}, String, Vector{Float64}, Vector{Float64}, Float64, Simulation}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a SimpleMarconato or SimpleAndersonFouad model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._make_reduced_jacobian_index-Tuple{Any, Any}","page":"Internal API Reference","title":"PowerSimulationsDynamics._make_reduced_jacobian_index","text":"Finds the location of the differential states in the reduced Jacobian\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._post_proc_state_series-Tuple{Any, Int64}","page":"Internal API Reference","title":"PowerSimulationsDynamics._post_proc_state_series","text":"Internal function to obtain as a Vector of Float64 of a specific state. It receives the solution and the global index for a state.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.build!-Tuple{PowerSimulationsDynamics.SimulationInputs, Type{ImplicitModel}, System}","page":"Internal API Reference","title":"PowerSimulationsDynamics.build!","text":"SimulationInputs build function for ImplicitModels\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.build!-Tuple{PowerSimulationsDynamics.SimulationInputs, Type{MassMatrixModel}, System}","page":"Internal API Reference","title":"PowerSimulationsDynamics.build!","text":"SimulationInputs build function for MassMatrixModels\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Union{Tuple{G}, Tuple{Simulation, G, Vector{Float64}, Vector{Float64}}} where G<:DynamicGenerator","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a Dynamic Generator model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific current.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Union{Tuple{G}, Tuple{Simulation, G, Vector{Float64}, Vector{Float64}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a Dynamic Inverter model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific current.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.configure_logging-Tuple{}","page":"Internal API Reference","title":"PowerSimulationsDynamics.configure_logging","text":"configure_logging(;\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\",\n)\n\nCreates console and file loggers.\n\nNote: Log messages may not be written to the file until flush() or close() is called on the returned logger.\n\nArguments\n\nconsole_level = Logging.Error: level for console messages\nfile_level = Logging.Info: level for file messages\nfilename::String = power-simulations.log: log file\n\nExample\n\nlogger = configure_logging(console_level = Logging.Info)\n@info \"log message\"\nclose(logger)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, DynamicGenerator{AndersonFouadMachine, S, A, TG, P}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 6-state (Anderson-Fouad) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, DynamicGenerator{BaseMachine, S, A, TG, P}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 0-state synchronous (classic model) machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, DynamicGenerator{MarconatoMachine, S, A, TG, P}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 6-state (Marconato) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, DynamicGenerator{OneDOneQMachine, S, A, TG, P}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 2-state (One d- and One q-) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, DynamicGenerator{SimpleAFMachine, S, A, TG, P}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 4-state (Simple Anderson-Fouad) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, DynamicGenerator{SimpleMarconatoMachine, S, A, TG, P}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 4-state (Simple Marconato) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.make_device_index!-Tuple{DynamicInjection, Vector{Bool}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.make_device_index!","text":"Default implementation to index the devices states and maps to the ports\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mass_matrix_entries-Tuple{DynamicInjection}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mass_matrix_entries","text":"Default implementation of mass matrix entries. Keeps the default values in the identity matrix\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, Any, Any, Float64, Float64, DynamicGenerator{AndersonFouadMachine, S, A, TG, P}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 6-state (AndersonFouadMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, Any, Any, Float64, Float64, DynamicGenerator{BaseMachine, S, A, TG, P}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 0-state synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, Any, Any, Float64, Float64, DynamicGenerator{MarconatoMachine, S, A, TG, P}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 6-state (MarconatoMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, Any, Any, Float64, Float64, DynamicGenerator{OneDOneQMachine, S, A, TG, P}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 2-state (One d- and One q-) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, Any, Any, Float64, Float64, DynamicGenerator{SimpleAFMachine, S, A, TG, P}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 4-state (SimpleAFMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, Any, Any, Float64, Float64, DynamicGenerator{SimpleMarconatoMachine, S, A, TG, P}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 4-state (SimpleMarconatoMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_activepower_series-Tuple{Simulation, String}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_activepower_series","text":"Function to compute the active power output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_reactivepower_series-Tuple{Simulation, String}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_reactivepower_series","text":"Function to compute the active power output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_state_series-Tuple{Simulation, Tuple{String, Symbol}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_state_series","text":"Function to obtain the state time series of a specific state. It receives the simulation, and a tuple containing the name of the Dynamic Device and the symbol of the state.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_voltage_current_series-Tuple{Simulation, String}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_voltage_current_series","text":"Function to obtain voltage and output currents for a dynamic device. It receives the simulation, and the name of the Dynamic Device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_voltage_series-Tuple{Any, Int64, Int64}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_voltage_series","text":"Function to obtain voltage using the bus index (and not the bus number). It receives the solution, the bus index and the total number of buses.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.saturation_function-Tuple{Union{RoundRotorExponential, SalientPoleExponential}, Real}","page":"Internal API Reference","title":"PowerSimulationsDynamics.saturation_function","text":"Saturation function for exponential saturation models for machines\n    Se(x) = B * x^A\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.saturation_function-Tuple{Union{RoundRotorQuadratic, SalientPoleQuadratic}, Real}","page":"Internal API Reference","title":"PowerSimulationsDynamics.saturation_function","text":"Saturation function for quadratic saturation models for machines\n    Se(x) = B * (x - A)^2 / x\n\n\n\n\n\n","category":"method"},{"location":"component_models/converter/#Converter","page":"Converter","title":"Converter","text":"","category":"section"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"This component can be used to model the dynamics of the switching process.","category":"page"},{"location":"component_models/converter/#Average-Model-[AverageConverter]","page":"Converter","title":"Average Model [AverageConverter]","text":"","category":"section"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"The average model outputs the desired reference signal since:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign\nv_d^textcv approx m_d v_textdc approx fracv_d^textref-signalv_textdc v_textdc approx v_d^textref-signal tag1a \nv_q^textcv approx m_q v_textdc approx fracv_q^textref-signalv_textdc v_textdc approx v_q^textref-signal tag1b\nendalign","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"where m_dq is the modulation signal, and v_dq^textref-signal is the voltage reference signal from the inner loop control.","category":"page"},{"location":"#PowerSimulationsDynamics.jl","page":"Welcome Page","title":"PowerSimulationsDynamics.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = PowerSystems","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulationsDynamics.jl is a Julia package for doing Power Systems Dynamic Modeling with Low Inertia Energy Sources.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The synchronous machine components supported here are based on commercial models and the academic components are derived from Power System Modelling and Scripting.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Inverter models support the model in \"A Virtual Synchronous Machine implementation for distributed control of power converters in SmartGrids\"","category":"page"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The latest stable release of PowerSimulationsDynamics can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerSimulationsDynamics","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerSimulationsDynamics#master","category":"page"},{"location":"#Structure","page":"Welcome Page","title":"Structure","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The following figure shows the interactions between PowerSimulationsDynamics.jl, PowerSystems.jl, DifferentialEquations.jl and the integrators. The architecture of PowerSimulationsDynamics.jl  is such that the power system models are all self-contained and return the model function evaluations. The Jacobian is calculated through DifferentialEquations.jl's common-interface enabling the use of any solver available in Julia. Considering that the resulting models are differential-algebraic equations (DAE), the implementation focuses on the use of implicit solvers, in particular SUNDIALS since it has exceptional features applicable to large models â for instance, interfacing with distributed linear-solvers and GPU arrays. In addition, automatic differentiation is implemented using ForwardDiff.jl to obtain jacobians to perform small signal analysis.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"<img src=\"./assets/SoftwareLoop.png\" width=\"65%\"/>","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"â ","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulationsDynamics has been developed as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (NREL)","category":"page"}]
}
